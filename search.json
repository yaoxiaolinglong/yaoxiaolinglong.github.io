[{"title":"Java常见关键字总结","date":"2021-04-09T08:19:20.000Z","url":"/2021/04/09/Java%E5%B8%B8%E8%A7%81%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93/","tags":[["Conclusion","/tags/Conclusion/"]],"categories":[["总结","/categories/%E6%80%BB%E7%BB%93/"]],"content":"关键字，意思是最终的、不可修改的，最见不得变化 ，用来修饰类、方法和变量，具有以下特点： 修饰的类不能被继承，final类中的所有成员方法都会被隐式的指定为final方法； 修饰的方法不能被重写； 修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。 原文地址，此处仅作展示！ final,static,this,super 关键字总结final 关键字final关键字，意思是最终的、不可修改的，最见不得变化 ，用来修饰类、方法和变量，具有以下特点： final修饰的类不能被继承，final类中的所有成员方法都会被隐式的指定为final方法； final修饰的方法不能被重写； final修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。 说明：使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。 static 关键字static 关键字主要有以下四种使用场景： 修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名() 静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次. 静态内部类（static修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。 静态导包(用来导入类中的静态资源，1.5之后的新特性): 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。 this 关键字this关键字用于引用类的当前实例。 例如： 在上面的示例中，this关键字用于两个地方： this.employees.length：访问类Manager的当前实例的变量。 this.report（）：调用类Manager的当前实例的方法。 此关键字是可选的，这意味着如果上面的示例在不使用此关键字的情况下表现相同。 但是，使用此关键字可能会使代码更易读或易懂。 super 关键字super关键字用于从子类访问父类的变量和方法。 例如： 在上面的例子中，Sub 类访问父类成员变量 number 并调用其其父类 Super 的 showNumber（） 方法。 使用 this 和 super 要注意的问题： 在构造器中使用 super() 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。 this、super不能用在static方法中。 简单解释一下： 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西。 参考 www.codejava.netblog.csdn.net static 关键字详解static 关键字主要有以下四种使用场景 修饰成员变量和成员方法 静态代码块 修饰类(只能修饰内部类) 静态导包(用来导入类中的静态资源，1.5之后的新特性) 修饰成员变量和成员方法(常用)被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。 方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。 HotSpot 虚拟机中方法区也常被称为 “永久代”，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。 调用格式： 类名.静态变量名 类名.静态方法名() 如果变量或者方法被 private 则代表该属性或者该方法只能在类的内部被访问而不能在类的外部被访问。 测试方法： 静态代码块静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块 —&gt; 非静态代码块 —&gt; 构造方法)。 该类不管创建多少对象，静态代码块只执行一次. 静态代码块的格式是 一个类中的静态代码块可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果静态代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。 静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问. 静态内部类静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着： 它的创建是不需要依赖外围类的创建。 它不能使用任何外围类的非static成员变量和方法。 Example（静态内部类实现单例模式） 当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 getUniqueInstance() 方法从而触发 SingletonHolder.INSTANCE 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。 这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。 静态导包格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法 补充内容静态方法与非静态方法静态方法属于类本身，非静态方法属于从该类生成的每个对象。 如果您的方法执行的操作不依赖于其类的各个变量和方法，请将其设置为静态（这将使程序的占用空间更小）。 否则，它应该是非静态的。 Example 你可以像这样调用静态方法：Foo.method1()。 如果您尝试使用这种方法调用 method2 将失败。 但这样可行 总结： 在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制 static&#123;&#125;静态代码块与&#123;&#125;非静态代码块(构造代码块)相同点： 都是在JVM加载类时且在构造方法执行之前执行，在类中都可以定义多个，定义多个时按定义的顺序执行，一般在代码块中对一些static变量进行赋值。 不同点： 静态代码块在非静态代码块之前执行(静态代码块 -&gt; 非静态代码块 -&gt; 构造方法)。静态代码块只在第一次new执行一次，之后不再执行，而非静态代码块在每new一次就执行一次。 非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。 修正 issue #677：静态代码块可能在第一次new的时候执行，但不一定只在第一次new的时候执行。比如通过 Class.forName(&quot;ClassDemo&quot;)创建 Class 对象的时候也会执行。 一般情况下,如果有些代码比如一些项目最常用的变量或对象必须在项目启动的时候就执行的时候,需要使用静态代码块,这种代码是主动执行的。如果我们想要设计不需要创建对象就可以调用类中的方法，例如：Arrays类，Character类，String类等，就需要使用静态方法, 两者的区别是 静态代码块是自动执行的而静态方法是被调用的时候才执行的. Example： 上述代码输出： 当只执行 Test.test(); 时输出： 当只执行 Test test = new Test(); 时输出： 非静态代码块与构造函数的区别是： 非静态代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化，因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。 参考 blog.csdn.netchenssyQian123 "},{"title":"Java基础知识","date":"2021-04-09T06:55:48.000Z","url":"/2021/04/09/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","tags":[["Conclusion","/tags/Conclusion/"]],"categories":[["总结","/categories/%E6%80%BB%E7%BB%93/"]],"content":"Java 语言有哪些特点? 简单易学； 面向对象（封装，继承，多态）； 平台无关性（ Java 虚拟机实现平台无关性）； 可靠性； 安全性； 原文地址，此处仅作展示！ Java 基本功Java 入门（基础概念与常识）Java 语言有哪些特点? 简单易学； 面向对象（封装，继承，多态）； 平台无关性（ Java 虚拟机实现平台无关性）； 可靠性； 安全性； 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）； 支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）； 编译与解释并存； 修正（参见： issue#544）：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用std::thread和std::async来创建线程。参考链接：www.cplusplus.com 关于 JVM JDK 和 JRE 最详细通俗的解答JVMJava 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。 什么是字节码?采用字节码的好处是什么? 在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。 Java 程序从源代码到运行一般有下面 3 步： 我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。 HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。 总结： Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。 JDK 和 JREJDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。 JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。 如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。 Oracle JDK 和 OpenJDK 的对比可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么 Oracle 和 OpenJDK 之间是否存在重大差异？下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。 对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外，OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。关于 JVM，JDK，JRE 和 OpenJDK 之间的区别，Oracle 博客帖子在 2012 年有一个更详细的答案： 问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？ 答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些封闭的源代码派对组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。 总结： Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次。但这不是固定的，我觉得了解这个没啥用处。详情参见：blogs.oracle.com 。 OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的； Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题； 在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能； Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本； Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。 Java 和 C++的区别?我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来！ 都是面向对象的语言，都支持封装、继承和多态 Java 不提供指针来直接访问内存，程序内存更加安全 Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。 Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存 在 C 语言中，字符串或字符数组最后都会有一个额外的字符&#39;\\0&#39;来表示结束。但是，Java 语言中没有结束符这一概念。 这是一个值得深度思考的问题，具体原因推荐看这篇文章： details/49148189 import java 和 javax 有什么区别？刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。 所以，实际上 java 和 javax 没有区别。这都是一个名字。 为什么说 Java 语言“编译与解释并存”？高级编程语言按照程序的执行方式分为编译型和解释型两种。简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。比如，你想阅读一本英文名著，你可以找一个英文翻译人员帮助你阅读，有两种选择方式，你可以先等翻译人员将全本的英文名著（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。 Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（*.class 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存。 Java 语法字符型常量和字符串常量的区别? 形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的 0 个或若干个字符 含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置) 占内存大小 字符常量只占 2 个字节; 字符串常量占若干个字节 (注意： char 在 Java 中占两个字节), 字符封装类 Character 有一个成员常量 Character.SIZE 值为 16,单位是bits,该值除以 8(1byte=8bits)后就可以得到 2 个字节 java 编程思想第四版：2.2.2 节 关于注释？Java 中的注释有三种： 单行注释 多行注释 文档注释。 在我们编写代码的时候，如果代码量比较少，我们自己或者团队其他成员还可以很轻易地看懂代码，但是当项目结构一旦复杂起来，我们就需要用到注释了。注释并不会执行(编译器在编译代码之前会把代码中的所有注释抹掉,字节码中不保留注释)，是我们程序员写给自己看的，注释是你的代码说明书，能够帮助看代码的人快速地理清代码之间的逻辑关系。因此，在写程序的时候随手加上注释是一个非常好的习惯。 《Clean Code》这本书明确指出： 代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。 若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。 举个例子： 去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可 应替换为 标识符和关键字的区别是什么？在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了标识符，简单来说，标识符就是一个名字。但是有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这种特殊的标识符就是关键字。因此，关键字是被赋予特殊含义的标识符。比如，在我们的日常生活中 ，“警察局”这个名字已经被赋予了特殊的含义，所以如果你开一家店，店的名字不能叫“警察局”，“警察局”就是我们日常生活中的关键字。 Java 中有哪些常见的关键字？ 访问控制 private protected public 类，方法和变量修饰符 abstract class extends final implements interface native new static strictfp synchronized transient volatile 程序控制 break continue return do while if else for instanceof switch case default 错误处理 try catch throw throws finally 包相关 import package 基本类型 boolean byte char double float int long short null true false 变量引用 super this void 保留字 goto const 自增自减运算符在写代码的过程中，常见的一种情况是需要某个整数类型变量增加 1 或减少 1，Java 提供了一种特殊的运算符，用于这种表达式，叫做自增运算符（++)和自减运算符（–）。 ++和–运算符可以放在变量之前，也可以放在变量之后，当运算符放在变量之前时(前缀)，先自增/减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增/减。例如，当 b = ++a 时，先自增（自己增加 1），再赋值（赋值给 b）；当 b = a++ 时，先赋值(赋值给 b)，再自增（自己增加 1）。也就是，++a 输出的是 a+1 的值，a++输出的是 a 值。用一句口诀就是：“符号在前就先加/减，符号在后就后加/减”。 continue、break、和 return 的区别是什么？在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词： continue ：指跳出当前的这一次循环，继续下一次循环。 break ：指跳出整个循环体，继续执行循环下面的语句。 return 用于跳出所在方法，结束该方法的运行。return 一般有两种用法： return; ：直接使用 return 结束方法执行，用于没有返回值函数的方法 return value; ：return 一个特定值，用于有返回值函数的方法 Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。 Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。 更多关于类型擦除的问题，可以查看这篇文章：《Java 泛型类型擦除以及类型擦除带来的问题》 。 泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。 1.泛型类： 如何实例化泛型类： 2.泛型接口 ： 实现泛型接口，不指定类型： 实现泛型接口，指定类型： 3.泛型方法 ： 使用： 常用的通配符为： T，E，K，V，？ ？ 表示不确定的 java 类型 T (type) 表示具体的一个 java 类型 K V (key value) 分别代表 java 键值中的 Key Value E (element) 代表 Element 更多关于 Java 泛型中的通配符可以查看这篇文章：《聊一聊-JAVA 泛型中的通配符 T，E，K，V，？》 ==和 equals 的区别== : 它的作用是判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址) 因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。 equals() : 它的作用也是判断两个对象是否相等，它不能用于比较基本数据类型的变量。equals()方法存在于Object类中，而Object类是所有类的直接或间接父类。 Object类equals()方法： equals() 方法存在两种使用情况： 情况 1：类没有覆盖 equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。使用的默认是 Object类equals()方法。 情况 2：类覆盖了 equals()方法。一般，我们都覆盖 equals()方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。 举个例子： 说明： String 中的 equals 方法是被重写过的，因为 Object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。 String类equals()方法： hashCode()与 equals()面试官可能会问你：“你重写过 hashcode 和 equals么，为什么重写 equals 时必须重写 hashCode 方法？” 1)hashCode()介绍: hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象） 2)为什么要有 hashCode？ 我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode？ 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head First Java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。 3)为什么重写 equals 时必须重写 hashCode 方法？ 如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖。 hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据） 4)为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？ 在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。 因为 hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode。 我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。 更多关于 hashcode() 和 equals() 的内容可以查看：Java hashCode() 和 equals()的若干问题解答 基本数据类型Java 中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？Java中有 8 种基本数据类型，分别为： 6 种数字类型 ：byte、short、int、long、float、double 1 种字符类型：char 1 种布尔型：boolean。 这八种基本类型都有对应的包装类分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean 基本类型 位数 字节 默认值 int 32 4 0 short 16 2 0 long 64 8 0L byte 8 1 0 char 16 2 ‘u0000’ float 32 4 0f double 64 8 0d boolean 1 false 对于 boolean，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。 注意： Java 里使用 long 类型的数据一定要在数值后面加上 L，否则将作为整型解析： char a = &#39;h&#39;char :单引号，String a = &quot;hello&quot; :双引号 自动装箱与拆箱 装箱：将基本类型用它们对应的引用类型包装起来； 拆箱：将包装类型转换为基本数据类型； 更多内容见：深入剖析 Java 中的装箱和拆箱 8 种基本类型的包装类和常量池Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True Or False。如果超出对应范围仍然会去创建新的对象。 为啥把缓存设置为[-128，127]区间？（参见 issue/461）性能和资源之间的权衡。 两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。 Integer 缓存源代码： 应用场景： Integer i1=40；Java 在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。 Integer i1 = new Integer(40);这种情况下会创建新的对象。 Integer 比较更丰富的一个例子: 结果： 解释： 语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。 方法（函数）什么是方法的返回值?返回值在类的方法里的作用是什么?方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用是接收出结果，使得它可以用于其他的操作！ 为什么 Java 中只有值传递？首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是 Java)中方法参数传递方式。 Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。 下面通过 3 个例子来给大家说明 example 1 结果： 解析： 在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 中的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。 通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2. example 2 结果： 解析： array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的是同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。 通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。 很多程序设计语言（特别是，C++和 Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为 Java 程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。 example 3 结果： 解析： 交换之前： 交换之后： 通过上面两张图可以很清晰的看出： 方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝 总结 Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。 下面再总结一下 Java 中方法参数的使用情况： 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。 一个方法可以改变一个对象参数的状态。 一个方法不能让对象参数引用一个新的对象。 参考： 《Java 核心技术卷 Ⅰ》基础知识第十版第四章 4.5 小节 重载和重写的区别 重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理 重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法 重载： 发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。 下面是《Java 核心技术》对重载这个概念的介绍： 综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。 重写： 重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。 返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。 如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。 构造方法无法被重写 综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变 暖心的 Guide 哥最后再来个图表总结一下！ 区别点 重载方法 重写方法 发生范围 同一个类 子类 参数列表 必须修改 一定不能修改 返回类型 可修改 子类方法返回值类型应比父类方法返回值类型更小或相等 异常 可修改 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； 访问修饰符 可修改 一定不能做更严格的限制（可以降低限制） 发生阶段 编译期 运行期 方法的重写要遵循“两同两小一大”（以下内容摘录自《疯狂 Java 讲义》,issue#892 ）： “两同”即方法名相同、形参列表相同； “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。 ⭐️ 关于 重写的返回值类型 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是void和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。 深拷贝 vs 浅拷贝 浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。 深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。 方法的四种类型1、无参数无返回值的方法 2、有参数无返回值的方法 3、有返回值无参数的方法 4、有返回值有参数的方法 5、return 在无返回值方法的特殊使用 Java 面向对象类和对象面向对象和面向过程的区别 面向过程 ：面向过程性能比面向对象高。 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。 面向对象 ：面向对象易维护、易复用、易扩展。 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，面向对象性能比面向过程低。 参见 issue : 面向过程 ：面向过程性能比面向对象高？？ 这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。 而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。 构造器 Constructor 是否可被 override?Constructor 不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。 在 Java 中定义一个不做事且没有参数的构造方法的作用Java 程序在执行子类的构造方法之前，如果没有用 super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super()来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。 成员变量与局部变量的区别有哪些？ 从语法形式上看:成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。 从变量在内存中的存储方式来看:如果成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。 从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。 成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。 创建一个对象用什么运算符?对象实体与对象引用有何不同?new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了，所以我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。 构造方法有哪些特性？ 名字与类名相同。 没有返回值，但不能用 void 声明构造函数。 生成类的对象时自动执行，无需调用。 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?帮助子类做初始化工作。 对象的相等与指向他们的引用相等,两者有什么不同?对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。 面向对象三大特征封装封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。 继承不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。 关于继承如下 3 点请记住： 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。（以后介绍）。 多态多态，顾名思义，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。 多态的特点: 对象类型和引用类型之间具有继承（类）/实现（接口）的关系； 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定； 多态不能调用“只在子类存在但在父类不存在”的方法； 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。 修饰符在一个静态方法内调用一个非静态成员为什么是非法的?由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。 静态方法和实例方法有何不同 在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。 其它重要知识点String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?可变性 简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]，所以String 对象是不可变的。 补充（来自issue 675）：在 Java 9 之后，String 、StringBuilder 与 StringBuffer 的实现改用 byte 数组存储字符串 private final byte[] value 而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。 StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是AbstractStringBuilder 实现的，大家可以自行查阅源码。 AbstractStringBuilder.java 线程安全性 String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 性能 每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 对于三者使用的总结： 操作少量的数据: 适用 String 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer Object 类的常见方法总结Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法： == 与 equals(重要)== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。 equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况： 情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。 情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。 举个例子： 说明： String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。 hashCode 与 equals (重要)面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode 方法？” hashCode（）介绍hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象） 为什么要有 hashCode我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode： 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与该位置其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。 通过我们可以看出：hashCode() 的作用就是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。**hashCode()在散列表中才有用，在其它情况下没用**。在散列表中 hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。 hashCode（）与 equals（）的相关规定 如果两个对象相等，则 hashcode 一定也是相同的 两个对象相等,对两个对象分别调用 equals 方法都返回 true 两个对象有相同的 hashcode 值，它们也不一定是相等的 因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖 hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据） 推荐阅读：Java hashCode() 和 equals()的若干问题解答 Java 序列化中如果有些字段不想进行序列化，怎么办？对于不想进行序列化的变量，使用 transient 关键字修饰。 transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。 获取用键盘输入常用的两种方法方法 1：通过 Scanner 方法 2：通过 BufferedReader Java 核心技术反射机制何为反射？如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。 反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。 通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。 反射机制优缺点优点 ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利 缺点 ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。Java Reflection: Why is it so slow? 反射的应用场景像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。 但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。 这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。 比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 Method 来调用指定的方法。 另外，像 Java 中的一大利器 注解 的实现也用到了反射。 为什么你使用 Spring 的时候 ，一个@Component注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 @Value注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？ 这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。 异常Java 异常类层次结构图 图片来自： 图片来自： 在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类 Exception（异常）和 Error（错误）。Exception 能被程序本身处理(try-catch)， Error 是无法处理的(只能尽量避免)。 Exception 和 Error 二者都是 Java 异常处理的重要子类，各自都包含大量子类。 Exception :程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。 Error ：Error 属于程序无法处理的错误 ，我们没办法通过 catch 来进行捕获 。例如，Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。 受检查异常 Java 代码在编译过程中，如果受检查异常没有被 catch/throw 处理的话，就没办法通过编译 。比如下面这段 IO 操作的代码。 除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、ClassNotFoundException 、SQLException…。 不受检查异常 Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。 RuntimeException 及其子类都统称为非受检查异常，例如：NullPoin​terException、NumberFormatException（字符串转换为数字）、ArrayIndexOutOfBoundsException（数组越界）、ClassCastException（类型转换错误）、ArithmeticException（算术错误）等。 Throwable 类常用方法 public string getMessage():返回异常发生时的简要描述 public string toString():返回异常发生时的详细信息 public string getLocalizedMessage():返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage（）返回的结果相同 public void printStackTrace():在控制台上打印 Throwable 对象封装的异常信息 try-catch-finally try块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。 catch块： 用于处理 try 捕获到的异常。 finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。 在以下 3 种特殊情况下，finally 块不会被执行： 在 try 或 finally 块中用了 System.exit(int)退出程序。但是，如果 System.exit(int) 在异常语句之后，finally 还是会被执行 程序所在的线程死亡。 关闭 CPU。 下面这部分内容来自 issue 注意： 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下： 如果调用 f(2)，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。 使用 try-with-resources 来代替try-catch-finally 适用范围（资源的定义）： 任何实现 java.lang.AutoCloseable或者 java.io.Closeable 的对象 关闭资源和 final 的执行顺序： 在 try-with-resources 语句中，任何 catch 或 finally 块在声明的资源关闭后运行 《Effecitve Java》中明确指出： 面对必须要关闭的资源，我们总是应该优先使用 try-with-resources 而不是try-finally。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。try-with-resources语句让我们更容易编写必须要关闭的资源的代码，若采用try-finally则几乎做不到这点。 Java 中类似于InputStream、OutputStream 、Scanner 、PrintWriter等的资源都需要我们调用close()方法来手动关闭，一般情况下我们都是通过try-catch-finally语句来实现这个需求，如下： 使用 Java 7 之后的 try-with-resources 语句改造上面的代码: 当然多个资源需要关闭的时候，使用 try-with-resources 实现起来也非常简单，如果你还是用try-catch-finally可能会带来很多问题。 通过使用分号分隔，可以在try-with-resources块中声明多个资源。 多线程简述线程、程序、进程的基本概念。以及他们之间关系是什么?线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。 程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。 线程有哪些基本状态?Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。 线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）： 由上图可以看出： 线程创建之后它将处于 NEW（新建） 状态，调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 RUNNING（运行） 状态。 操作系统隐藏 Java 虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：HowToDoInJava：Java Thread Life Cycle and Thread States），所以 Java 系统一般将这两个状态统称为 RUNNABLE（运行中） 状态 。 当线程执行 wait()方法之后，线程进入 WAITING（等待） 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞） 状态。线程在执行 Runnable 的run()方法之后将会进入到 TERMINATED（终止） 状态。 文件与 I\\O 流Java 中 IO 流分为几种? 按照流的流向分，可以分为输入流和输出流； 按照操作单元划分，可以划分为字节流和字符流； 按照流的角色划分为节点流和处理流。 Java Io 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。 InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。 OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。 按操作方式分类结构图： 按操作对象分类结构图： 既然有了字节流,为什么还要有字符流?问题本质想问：不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？ 回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。 BIO,NIO,AIO 有什么区别? BIO (Blocking I/O): 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。 NIO (Non-blocking/New I/O): NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发 AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。 参考 stackoverflow.com/questions/1906445www.educba.comstackoverflow.com/questions/22358071 "},{"title":"永久免费的甲骨文oracle服务器注册教程及注意事项","date":"2021-01-29T13:37:48.000Z","url":"/2021/01/29/%E6%B0%B8%E4%B9%85%E5%85%8D%E8%B4%B9%E7%9A%84%E7%94%B2%E9%AA%A8%E6%96%87Oracle%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B3%A8%E5%86%8C%E6%95%99%E7%A8%8B%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","tags":[["Course","/tags/Course/"]],"categories":[["教程","/categories/%E6%95%99%E7%A8%8B/"]],"content":"永久免费的甲骨文oracle服务器注册教程及注意事项 &emsp;Oracle（甲骨文）的服务器！注册账号能永久免费使用2台云服务器以及数据库等服务！ &emsp;注册需要信用卡，虚拟卡难以注册，就算成功也会翻车，谨慎使用。国内主流的visa卡和万事通卡都可以尝试！ 原文地址，此处仅作展示，侵删！ 永久免费的甲骨文oracle服务器注册教程及注意事项 &emsp;Oracle（甲骨文）的服务器！注册账号能永久免费使用2台云服务器以及数据库等服务！ &emsp;注册需要信用卡，虚拟卡难以注册，就算成功也会翻车，谨慎使用。国内主流的visa卡和万事通卡都可以尝试！ 活动地址&emsp;注册链接 后台登录地址&emsp;日本区域 &emsp;韩国区域 &emsp;美西区域 &emsp;提醒一下，始终免费的服务仅支持在主区域(注册时选择的区域)！只要不点击【升级】无论怎么折腾不会造成信用卡的扣费！300美元的试用额度能嗨30天！ 注册步骤访问活动地址 点击【Start for Free】&emsp;邮箱尽量用谷歌、微软等国际邮箱，尽量不要用QQ，163等国内邮箱，非常容易注册失败，国家选中国。 完善相关信息&emsp;特别注意【Home Region】这里选择哪个区域就是你选择的主区域，只能在该主域内免费使用。 今年政策改版后已经不能改动，请谨慎选择！手机号可填国内手机号码！ 手机号码接收验证码完成完成验证！ 设置登录密码。请注意密码的要求，非常多！ 验证信用卡！&emsp;亲测交行青年卡VISA可用，普遍反映招行VISA和中行VISA双币也可以。 &emsp;验证要扣1新加坡元，会退还，这是预付费，大厂要放心（或者会显示扣费失败，实际验证成功）！ &emsp;然后需要打勾的地方点选，完成注册即可。 &emsp;一般大家说的失败就是最后这里了。不行了就换换浏览器，无痕模式，换邮箱和卡再试，注册信息的时候人名写拼音，不要乱写，也会导致失败！ 支付方式验证成功，就可以使用邮箱+密码登录平台了！免费服务&emsp;我主要讲一下免费服务器，其他大家基本上也用不到。 &emsp;注册完成后登录，直接创建实例即可。 &emsp;注意选择自己想要的镜像，已经看是否有符合始终免费条件字样。 &emsp;一定要保存好私有密钥！一定要保存好私有密钥！一定要保存好私有密钥！ &emsp;下图为小白指引。 &emsp;跳转后会有分配给你的IP地址，这时候是ping不通的，需要开放端口及ICMP设置 &emsp;点击蓝色实例名称会进入实例设置 &emsp;点击实例详细信息下的虚拟云网络（VNC-XXXXXX这个）来设置端口。 &emsp;点击子网，再进入安全列表。根据自己需求添加或修改入站规则。或者暴力一点清除全部规则。 &emsp;注意把ICMP下的类型和代码清除，不让IP是ping不通的。 SSH登录&emsp;我以我经常用的finalshell登录器，和centos7为例演示 现在这里找到用户名 添加SSH链接，主机填IP，方法选公钥，点击浏览选择刚才下载的私钥，用户名就是刚才找到的用户名。 切换至root账户&emsp;输入代码sudo -i &emsp;切换至root账户 &emsp;再输入代码passwd &emsp;更改root密码 使用服务器&emsp;这个就不用教了吧？想怎么用就怎么用！ &emsp;注意是再次用Finalshell登录的时候进入的不是root账户，输入su再输入root密码之后就会完成切换"},{"title":"常用正则表达式","date":"2021-01-29T09:34:16.000Z","url":"/2021/01/29/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","tags":[["Conclusion","/tags/Conclusion/"]],"categories":[["总结","/categories/%E6%80%BB%E7%BB%93/"]],"content":"密码验证类 6-16位字符，区分大小写（不能是9位以下的纯数字，不含空格）:^(?!\\d&#123;6,8&#125;$)(?! )(?=.*[a-z])(?=.*[0-9])[a-zA-Z0-9_]&#123;6,16&#125;$ 原文地址，此处仅作展示！可视化编辑测试工具 正则表达式 匹配2018-10-10格式的日期：^[1-9]\\d&#123;3&#125;-([1-9]|1[0-2])-([1-9]|[1-2]\\d|3[01])$ 验证文件扩展名:^.*?\\.(html|css|jpg)$ 密码验证类 6-16位字符，区分大小写（不能是9位以下的纯数字，不含空格）:^(?!\\d&#123;6,8&#125;$)(?! )(?=.*[a-z])(?=.*[0-9])[a-zA-Z0-9_]&#123;6,16&#125;$ 6-16位字符，区分大小写（不能是9位以下的纯数字，不含空格），必须包含大写字母:^(?!\\d&#123;6,8&#125;$)(?! )(?=.*[A-Z])(?=.*[a-z])(?=.*[0-9])[a-zA-Z0-9_]&#123;6,16&#125;$ 密码不能为纯数字或字母，不少于6位:^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]&#123;6,&#125;$ 号码验证类 验证微信号:^[a-zA-Z]&#123;1&#125;[-_a-zA-Z0-9]&#123;5,19&#125;$ 腾讯QQ号码:[1-9][0-9]&#123;4,&#125; 国内电话号码:\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\&#123;7,8&#125; 带中划线的手机号码:^[+]&#123;0,1&#125;(d)&#123;1,3&#125;[ ]?([-]?((d)|[ ])&#123;1,12&#125;)+$ 普通手机号码:^1[34578]\\d&#123;9&#125;$ 普通电话、传真号码：可以“+”开头，除数字外，可含有“-”:^[+]&#123;0,1&#125;(d)&#123;1,3&#125;[ ]?([-]?((d)|[ ])&#123;1,12&#125;)+$ 18位身份证号码:^(\\d&#123;6&#125;)(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d&#123;3&#125;)([0-9]|X|x)$ 中国邮政编码:[1-9]\\d&#123;5&#125;(?!\\d) 地址类 IP地址：(25[0-5]|2[0-4]\\d|[0-1]\\d&#123;2&#125;|[1-9]?\\d).(25[0-5]|2[0-4]\\d|[0-1]\\d&#123;2&#125;|[1-9]?\\d).(25[0-5]|2[0-4]\\d|[0-1]\\d&#123;2&#125;|[1-9]?\\d).(25[0-5]|2[0-4]\\d|[0-1]\\d&#123;2&#125;|[1-9]?\\d) URL:[a-zA-z]+://[^\\s]* Email地址:[\\w!#$%&amp;&#39;*+/=?^_&#123;|&#125;~-]+(?:.[\\w!#$%&amp;&#39;*+/=?^_&#123;|&#125;~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])? 匹配数字 验证数字：^[0-9]*$ 验证n位的数字：^\\d&#123;n&#125;$ 验证至少n位数字：^\\d&#123;n,&#125;$ 验证m-n位的数字：^\\d&#123;m,n&#125;$ 验证零和非零开头的数字：^(0|[1-9][0-9]*)$ 验证有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$ 验证有1-3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$ 验证非零的正整数：^\\+?[1-9][0-9]*$ 验证非零的负整数：^\\-[1-9][0-9]*$ 验证非负整数（正整数 + 0） ^\\d+$ 验证非正整数（负整数 + 0） ^((-\\d+)|(0+))$ 验证长度为3的字符：^.&#123;3&#125;$ 验证由26个英文字母组成的字符串：^[A-Za-z]+$ 验证由26个大写英文字母组成的字符串：^[A-Z]+$ 验证由26个小写英文字母组成的字符串：^[a-z]+$ 验证由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 验证由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 验证用户密码:^[a-zA-Z]\\w&#123;5,17&#125;$ 正确格式为：以字母开头，长度在6-18之间，只能包含字符、数字和下划线。 验证是否含有 ^%&amp;&#39;,;=?$\\&quot; 等字符：[^%&amp;&#39;,;=?$\\x22]+ 验证汉字：^[\\u4e00-\\u9fa5],&#123;0,&#125;$ 验证Email地址：^\\w+[-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 验证InternetURL：^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$ ；^[a-zA-z]+://(w+(-w+)*)(.(w+(-w+)*))*(?S*)?$ 验证电话号码：^(\\(\\d&#123;3,4&#125;\\)|\\d&#123;3,4&#125;-)?\\d&#123;7,8&#125;$：–正确格式为：XXXX-XXXXXXX，XXXX-XXXXXXXX，XXX-XXXXXXX，XXX-XXXXXXXX，XXXXXXX，XXXXXXXX。 验证身份证号（15位或18位数字）：^\\d&#123;15&#125;|\\d&#123;&#125;18$ 验证一年的12个月：^(0?[1-9]|1[0-2])$ 正确格式为：“01”-“09”和“1”“12” 验证一个月的31天：^((0?[1-9])|((1|2)[0-9])|30|31)$ 正确格式为：01、09和1、31。 整数：^-?\\d+$ 非负浮点数（正浮点数 + 0）：^\\d+(\\.\\d+)?$ 正浮点数 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 非正浮点数（负浮点数 + 0） ^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 负浮点数 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 浮点数 ^(-?\\d+)(\\.\\d+)?$ 其他手机号码中间四位用 * 代替 格式化金额 JS替换字符串中的空格 不允许输入如下字符: (像 !@#$%^&amp;* 等) tips匹配中文字符：[\\u4e00-\\u9fa5]"},{"title":"[活动预告] 危机合约 #4 赛季「铅封行动」即将开启","date":"2021-01-13T20:00:00.000Z","url":"/news/","tags":[["Activity","/tags/Activity/"]],"categories":[["活动","/categories/%E6%B4%BB%E5%8A%A8/"]],"content":" 一、危机合约，#4赛季「铅封行动」开启 赛季开启时间：01月19日 16:00 - 02月02日 03:59 危机合约解锁条件：通关主线 2-10 赛季说明：该赛季开启期间内，玩家可在赛季关卡中通过搭配不同「合约」进行作战，通过作战完成相关挑战任务提升关卡评价和收集「合约赏金」以及「行动协议」 ◆「合约赏金」可用于“机密圣所”中兑换补给 ◆「行动协议」可用于解锁更多危机合约内容 跨赛季“机密圣所”开放 ◆跨赛季常设兑换所兑换物品： ★★★★★：图耶 ★★★★★：图耶信物 珊瑚海岸系列 -“SUM019.ver” -Castle-3（复刻） #4赛季家具 - 铅封之旗 ◆#4赛季特设兑换所补给： 高级养成素材、龙门币、家具零件、作战记录、职业芯片等养成素材 ◆#4赛季特设兑换所开放兑换时间：01月19日 16:00 - 02月02日 03:59 【注意事项】 ◆「危机合约」玩法不会消耗理智 ◆部分「合约」解锁必须额外满足一定的“合约完成数”，合约完成数≠危机等级数 ◆#4赛季对比上赛季将删除2个上赛季轮换行动地点，新增1个轮换行动地点，1个常驻行动地点，上赛季常驻行动地点将在本赛季加入轮换，共计8个行动地点。赛季期间，可以挑战1个常驻行动地点，同时有7个轮换行动地点将进行每日轮换 （活动开启后的第一天的地图轮换时间及对应挑战任务将会延长一天） ◆#4赛季常驻关卡将在 01月26日04:00 新增若干「合约」及「挑战任务」 ◆#4赛季结束后，未使用的「合约赏金」将进行保留 ◆#4赛季结束后，累计获得的「行动协议」将自动兑换为「铅封行动物资补给」，兑换比例为1：1 ◆#4赛季期间，玩家每日可通过被使用支援单位用于支援他人通过危机合约来获取一定的信用 ◆#4赛季期间玩家还可通过完成相关目标获取该赛季专属蚀刻章 二、[限定寻访·春节]系列，【地生五金】复刻寻访开启 活动时间：01月19日 16:00 - 02月02日 03:59 活动说明：活动期间【限定寻访·春节】-【地生五金】复刻寻访开启，该寻访中以下干员出现率上升 ★★★★★★：年[限定] \\ 阿（占6★出率的70%） ★★★★★：吽（占5★出率的50%） 注意： ◆【地生五金】寻访为【限定寻访·春节】系列寻访 ◆【限定寻访·春节】寻访为【限定寻访】 ◆【地生五金】复刻寻访中可出现的干员将与最新一期的常驻【标准寻访】保持一致 ◆【地生五金】中登场的限定干员【年】属于【限定寻访·春节】限定干员 ◆对于在此前【地生五金】限定寻访中抽取的玩家将在【地生五金】复刻开启时获得抽取次数对应比例（1:1）的【寻访数据契约】，届时，该【寻访数据契约】可与【地生五金】复刻时寻访获得的【寻访数据契约】叠加使用 ◆该寻访详细说明请参照相关寻访公告说明 三、[0011]系列，限时复刻上架 活动时间：01月19日 16:00 - 02月02日 03:59 活动说明：活动期间以下干员时装将在时装商店上架并进行限时贩售： ◆0011系列-“岁红霞”- 陈 ◆0011系列-“富贵荣华”- 诗怀雅 ◆0011系列-“春竜”- 雷蛇 四、“物资筹备”“芯片搜索”限时全天开放 活动时间：01月19日 16:00 - 02月02日 03:59 活动说明：活动期间内“物资筹备”以及“芯片搜索”的所有关卡将进行全天开放 五、【公开招募】干员更新 更新时间：01月19日 16:00 更新说明：更新后，以下干员将加入并常驻【公开招募】 ★★★★★★：麦哲伦 ★★★★★：送葬人 ★★★★：红云 注意： 本次【公开招募】干员更新时，将对未开始进行招募的标签进行强制刷新，强制刷新注意事项及相关补偿请参照官方相关更新公告 更多活动内容请持续关注《明日方舟》游戏内公告、官网、官方微博及微信公众号 【明日方舟】运营组2021年01月14日"},{"title":"kotlin 基本类型","date":"2020-07-14T00:34:40.000Z","url":"/2020/07/14/kotlin%20%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/","tags":[["Conclusion","/tags/Conclusion/"]],"categories":[["总结","/categories/%E6%80%BB%E7%BB%93/"]],"content":"基本类型在 Kotlin 中，所有东西都是对象，在这个意义上讲我们可以在任何变量上调用成员函数与属性。一些类型可以有特殊的内部表示——例如，数字、字符以及布尔值可以在运行时表示为原生类型值，但是对于用户来说，它们看起来就像普通的类。在本节中，我们会描述 Kotlin 中使用的基本类型：数字、字符、布尔值、数组与字符串。 原文地址，此处仅作展示！ 基本类型在 Kotlin 中，所有东西都是对象，在这个意义上讲我们可以在任何变量上调用成员函数与属性。一些类型可以有特殊的内部表示——例如，数字、字符以及布尔值可以在运行时表示为原生类型值，但是对于用户来说，它们看起来就像普通的类。在本节中，我们会描述 Kotlin 中使用的基本类型：数字、字符、布尔值、数组与字符串。 数字Kotlin 提供了一组表示数字的内置类型。对于整数，有四种不同大小的类型，因此值的范围也不同。 类型 大小（比特数） 最小值 最大值 Byte 8 -128 127 Short 16 -32768 32767 Int 32 -2,147,483,648 (-231) 2,147,483,647 (231 - 1) Long 64 -9,223,372,036,854,775,808 (-263) 9,223,372,036,854,775,807 (263 - 1) 所有以未超出 Int 最大值的整型值初始化的变量都会推断为 Int 类型。如果初始值超过了其最大值，那么推断为 Long 类型。如需显式指定 Long 型值，请在该值后追加 L 后缀。 对于浮点数，Kotlin 提供了 Float 与 Double 类型。根据 IEEE 754 标准，两种浮点类型的十进制位数（即可以存储多少位十进制数）不同。Float 反映了 IEEE 754 单精度，而 Double 提供了双精度。 类型 大小（比特数） 有效数字比特数 指数比特数 十进制位数 Float 32 24 8 6-7 Double 64 53 11 15-16 对于以小数初始化的变量，编译器会推断为 Double 类型。 如需将一个值显式指定为 Float 类型，请添加 f 或 F 后缀。 如果这样的值包含多于 6～7 位十进制数，那么会将其舍入。 请注意，与一些其他语言不同，Kotlin 中的数字没有隐式拓宽转换。例如，具有 Double 参数的函数只能对 Double 值调用，而不能对 Float、Int 或者其他数字值调用。 如需将数值转换为不同的类型，请使用显示转换。 字面常量数值常量字面值有以下几种: 十进制: 123 Long 类型用大写 L 标记: 123L 十六进制: 0x0F 二进制: 0b00001011 注意: 不支持八进制 Kotlin 同样支持浮点数的常规表示方法: 默认 double：123.5、123.5e10 Float 用 f 或者 F 标记: 123.5f 数字字面值中的下划线（自 1.1 起）你可以使用下划线使数字常量更易读： 表示方式在 Java 平台数字是物理存储为 JVM 的原生类型，除非我们需要一个可空的引用（如 Int?）或泛型。后者情况下会把数字装箱。 注意数字装箱不一定保留同一性: 另一方面，它保留了相等性: 显式转换由于不同的表示方式，较小类型并不是较大类型的子类型。如果它们是的话，就会出现下述问题： 所以相等性会在所有地方悄无声息地失去，更别说同一性了。 因此较小的类型不能隐式转换为较大的类型。这意味着在不进行显式转换的情况下我们不能把 Byte 型值赋给一个 Int 变量。 我们可以显式转换来拓宽数字 每个数字类型支持如下的转换: toByte(): Byte toShort(): Short toInt(): Int toLong(): Long toFloat(): Float toDouble(): Double toChar(): Char 缺乏隐式类型转换很少会引起注意，因为类型会从上下文推断出来，而算术运算会有重载做适当转换，例如： 运算Kotlin支持数字运算的标准集（+ - * / %），运算被定义为相应的类成员（但编译器会将函数调用优化为相应的指令）。参见运算符重载。 整数除法请注意，整数间的除法总是返回整数。会丢弃任何小数部分。例如： 对于任何两个整数类型之间的除法来说都是如此。 如需返回浮点类型，请将其中的一个参数显式转换为浮点类型。 位运算对于位运算，没有特殊字符来表示，而只可用中缀方式调用具名函数，例如: 这是完整的位运算列表（只用于 Int 与 Long）： shl(bits) – 有符号左移 shr(bits) – 有符号右移 ushr(bits) – 无符号右移 and(bits) – 位与 or(bits) – 位或 xor(bits) – 位异或 inv() – 位非 浮点数比较本节讨论的浮点数操作如下： 相等性检测：a == b 与 a != b 比较操作符：a &lt; b、 a &gt; b、 a &lt;= b、 a &gt;= b 区间实例以及区间检测：a..b、 x in a..b、 x !in a..b 当其中的操作数 a 与 b 都是静态已知的 Float 或 Double 或者它们对应的可空类型（声明为该类型，或者推断为该类型，或者智能类型转换的结果是该类型），两数字所形成的操作或者区间遵循 IEEE 754 浮点运算标准。 然而，为了支持泛型场景并提供全序支持，当这些操作数并非静态类型为浮点数（例如是 Any、 Comparable&lt;……&gt;、 类型参数）时，这些操作使用为 Float 与 Double 实现的不符合标准的 equals 与 compareTo，这会出现： 认为 NaN 与其自身相等 认为 NaN 比包括正无穷大（POSITIVE_INFINITY）在内的任何其他元素都大 认为 -0.0 小于 0.0 字符字符用 Char 类型表示。它们不能直接当作数字 字符字面值用单引号括起来: &#39;1&#39;。特殊字符可以用反斜杠转义。支持这几个转义序列：\\t、 \\b、\\n、\\r、\\&#39;、\\&quot;、\\\\ 与 \\$。编码其他字符要用 Unicode 转义序列语法：&#39;\\uFF00&#39;。 我们可以显式把字符转换为 Int 数字： 当需要可空引用时，像数字、字符会被装箱。装箱操作不会保留同一性。 布尔布尔用 Boolean 类型表示，它有两个值：true{: .keyword } 与 false{: .keyword }。 若需要可空引用布尔会被装箱。 内置的布尔运算有： || – 短路逻辑或 &amp;&amp; – 短路逻辑与 ! - 逻辑非 数组数组在 Kotlin 中使用 Array 类来表示，它定义了 get 与 set 函数（按照运算符重载约定这会转变为 []）以及 size 属性，以及一些其他有用的成员函数： 我们可以使用库函数 arrayOf() 来创建一个数组并传递元素值给它，这样 arrayOf(1, 2, 3) 创建了 array [1, 2, 3]。或者，库函数 arrayOfNulls() 可以用于创建一个指定大小的、所有元素都为空的数组。 另一个选项是用接受数组大小以及一个函数参数的 Array 构造函数，用作参数的函数能够返回给定索引的每个元素初始值： 如上所述，[] 运算符代表调用成员函数 get() 与 set()。 Kotlin 中数组是不型变的（invariant）。这意味着 Kotlin 不让我们把 Array&lt;String&gt;赋值给 Array&lt;Any&gt;，以防止可能的运行时失败（但是你可以使用 Array&lt;out Any&gt;,参见类型投影）。 原生类型数组Kotlin 也有无装箱开销的专门的类来表示原生类型数组: ByteArray、ShortArray、IntArray 等等。这些类与 Array 并没有继承关系，但是它们有同样的方法属性集。它们也都有相应的工厂方法: 无符号整型 无符号类型自 Kotlin 1.3 起才可用，并且目前是实验性的。详见下文{:.note} Kotlin 为无符号整数引入了以下类型： kotlin.UByte: 无符号 8 比特整数，范围是 0 到 255 kotlin.UShort: 无符号 16 比特整数，范围是 0 到 65535 kotlin.UInt: 无符号 32 比特整数，范围是 0 到 2^32 - 1 kotlin.ULong: 无符号 64 比特整数，范围是 0 到 2^64 - 1 无符号类型支持其对应有符号类型的大多数操作。 请注意，将类型从无符号类型更改为对应的有符号类型（反之亦然）是二进制不兼容变更{:.note} 无符号类型是使用另一个实验性特性（即内联类）实现的。 特化的类与原生类型相同，每个无符号类型都有相应的为该类型特化的表示数组的类型： kotlin.UByteArray: 无符号字节数组 kotlin.UShortArray: 无符号短整型数组 kotlin.UIntArray: 无符号整型数组 kotlin.ULongArray: 无符号长整型数组 与有符号整型数组一样，它们提供了类似于 Array 类的 API 而没有装箱开销。 此外，区间与数列也支持 UInt 与 ULong（通过这些类 kotlin.ranges.UIntRange、 kotlin.ranges.UIntProgression、 kotlin.ranges.ULongRange、 kotlin.ranges.ULongProgression） 字面值为使无符号整型更易于使用，Kotlin 提供了用后缀标记整型字面值来表示指定无符号类型（类似于 Float/Long）： 后缀 u 与 U 将字面值标记为无符号。确切类型会根据预期类型确定。如果没有提供预期的类型，会根据字面值大小选择 UInt 或者 ULong 后缀 uL 与 UL 显式将字面值标记为无符号长整型。 无符号整型的实验性状态无符号类型的设计是实验性的，这意味着这个特性改进很快并且没有给出兼容性保证。当在 Kotlin 1.3+ 中使用无符号算术时，会报出警告表明这个特性是实验性的。如需移除警告，必须选择加入（opt-in）无符号类型的实验性使用。 选择加入无符号整型有两种可行的方式：将 API 标记为实验性的，或者无需标记。 如需传播实验性，请以 @ExperimentalUnsignedTypes 标注使用了无符号整型的声明。 如需选择加入而不传播实验性，要么使用 @OptIn(ExperimentalUnsignedTypes::class) 注解标注声明，要么将 -Xopt-in=kotlin.ExperimentalUnsignedTypes 传给编译器。 你的客户是否必须选择使用你的 API 取决于你，不过请记住，无符号整型是一个实验性特性，因此使用它们的 API 可能会因语言的变更而发生突然破坏。 技术细节也参见实验性 API KEEP。 深入探讨关于技术细节与深入探讨请参见无符号类型的语言提案。 字符串字符串用 String 类型表示。字符串是不可变的。字符串的元素——字符可以使用索引运算符访问: s[i]。可以用 for{: .keyword } 循环迭代字符串: 可以用 + 操作符连接字符串。这也适用于连接字符串与其他类型的值，只要表达式中的第一个元素是字符串： 请注意，在大多数情况下，优先使用字符串模板或原始字符串而不是字符串连接。 字符串字面值Kotlin 有两种类型的字符串字面值: 转义字符串可以有转义字符，以及原始字符串可以包含换行以及任意文本。以下是转义字符串的一个示例: 转义采用传统的反斜杠方式。参见上面的 字符 查看支持的转义序列。 原始字符串 使用三个引号（&quot;&quot;&quot;）分界符括起来，内部没有转义并且可以包含换行以及任何其他字符: 你可以通过 trimMargin() 函数去除前导空格： 默认 | 用作边界前缀，但你可以选择其他字符并作为参数传入，比如 trimMargin(&quot;&gt;&quot;)。 字符串模板字符串字面值可以包含模板表达式 ，即一些小段代码，会求值并把结果合并到字符串中。模板表达式以美元符（$）开头，由一个简单的名字构成: 或者用花括号括起来的任意表达式: 原始字符串与转义字符串内部都支持模板。如果你需要在原始字符串中表示字面值 $ 字符（它不支持反斜杠转义），你可以用下列语法： "},{"title":"Hello World !","date":"2020-04-15T13:54:02.000Z","url":"/2020/04/15/helloworld/","tags":[["Example","/tags/Example/"]],"categories":[["例子","/categories/%E4%BE%8B%E5%AD%90/"]],"content":" 这儿有一些代码示例~ Apache Bash CoffeeScript C++ C# CSS diff 使用主题：Atom One Dark Reasonable查看更多示例：Highlight.js demo "},{"title":"Markdown 教程","date":"2020-04-14T16:58:59.000Z","url":"/2020/04/15/markdown/","tags":[["Course","/tags/Course/"]],"categories":[["教程","/categories/%E6%95%99%E7%A8%8B/"]],"content":" Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。Markdown 编写的文档后缀为 .md, .markdown。 标题👆 看起来就像上面这个。Markdown 标题有两种格式。 使用 = 和 - 标记一级和二级标题= 和 - 标记语法格式如下： 使用 # 号标记使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。 段落样式Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。当然也可以在段落后面使用一个空行来表示重新开始一个段落。 字体Markdown 可以使用以下几种字体： 斜体文本粗体文本粗斜体文本 分隔线可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： 我 裂 开 了 删除线如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下： RUNOOB.COMGOOGLE.COMBAIDU.COM 下划线下划线可以通过 HTML 的 &lt;u&gt; 标签来实现： 带下划线文本 脚注脚注是对文本的补充说明。Markdown 脚注的格式如下: 以下实例演示了脚注的用法： 阿米娅^阿米娅 Markdown 列表Markdown 支持有序列表和无序列表。无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记： 第一项 第二项 第三项 有序列表使用数字并加上 . 号来表示，如： 第一项 第二项 第三项 列表嵌套列表嵌套只需在子列表中的选项添加四个空格即可： 第一项： 第一项嵌套的第一个元素 第一项嵌套的第二个元素 第二项： 第二项嵌套的第一个元素 第二项嵌套的第二个元素 Markdown 区块Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号： 这是一个区块 另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推： 最外层 第一层嵌套 第二层嵌套 区块中使用列表区块中使用列表实例如下： 区块中使用列表 第一项 第二项 第一项 第二项 第三项 列表中使用区块如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。区块中使用列表实例如下： 第一项 菜鸟教程学的不仅是技术更是梦想 第二项 Markdown 代码如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：printf() 函数 代码区块代码区块使用 4 个空格或者一个制表符（Tab 键）。也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：实例如下： Markdown 链接链接使用方法如下： 链接名称或者直接使用链接地址 高级链接可以通过变量来设置一个链接，变量赋值在文档末尾进行： 这个链接用 1 作为网址变量 Google这个链接用 mysite 作为网址变量 Yue_plus Markdown 图片Markdown 图片语法格式如下： 开头一个感叹号 !接着一个方括号，里面放上图片的替代文字接着一个英文括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。 当然，你也可以像网址那样对图片网址使用变量: Markdown 还没有办法指定图片的高度与宽度，如果需要的话，也可以使用普通的 &lt;img&gt; 标签。 Markdown 表格Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。语法格式如下： 表头 表头 单元格 单元格 单元格 单元格 可以设置表格的对齐方式： -: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 Markdown 高级技巧##支持的 HTML 元素不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等，如： 使用 Ctrl+Alt+Del 重启电脑 转义Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符： ** 正常显示星号 ** Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： 公式当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如： 参考 使用 hexo-filter-mathjax 过滤器来显示数学公式 可以在行内包含数学公式： 注意单 $ 内部不能有空格！ "},{"title":"这是一篇拥有很长目录的文章","date":"2020-04-11T16:04:40.000Z","url":"/2020/04/12/longindex/","tags":[["Example","/tags/Example/"]],"categories":[["例子","/categories/%E4%BE%8B%E5%AD%90/"]],"content":"这儿是长目录示例~ 如果在 hexo serve --debug 下，会看到这篇文章无法全部渲染。这是由热重载插件 hexo-browsersync 导致的，不会影响发布。 试试侧边栏的目录吧~ (｡･∀･)ﾉﾞ一级标题 (/ω＼*)……… (/ω•＼*) 长一些的一级标题 （づ￣3￣）づ╭❤～长一些的二级标题 ヽ(￣ω￣(￣ω￣〃)ゝ)很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长的一级标题很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长的二级标题一级标题卡耐基说过一句富有哲理的话，我们若已接受最坏的，就再没有什么损失。 二级标题这似乎解答了我的疑惑。 三级标题那么，这一大段文章，到底应该如何实现。 四级标题总结的来说，鲁巴金曾经说过，读书是在别人思想的帮助下，建立起自己的思想。 五级标题这启发了我，所谓这一大段文章，关键是这一大段文章需要如何写。 六级标题要想清楚， 六级标题这一大段文章 六级标题，到底是一种怎么样的存在。 五级标题一般来说， 六级标题就我个人来说， 六级标题这一大段文章对我的意义， 六级标题不能不说非常重大 六级标题。总结的来说， 六级标题这一大段文章， 六级标题到底应该如何实现 六级标题。问题的关键究竟为何？ 六级标题本人也是经过了深思熟虑， 六级标题在每个日日夜夜思考这个问题 三级标题。这一大段文章的发生， 六级标题到底需要如何做到， 六级标题不这一大段文章的发生， 六级标题又会如何产生 六级标题。从这个角度来看， 六级标题这一大段文章的发生， 六级标题到底需要如何做到， 六级标题不这一大段文章的发生， 六级标题又会如何产生 六级标题。我们不得不面对一个非常尴尬的事实， 六级标题那就是， 六级标题既然如何， 六级标题这一大段文章， 六级标题发生了会如何， 六级标题不发生又会如何。 六级标题对我个人而言， 六级标题这一大段文章不仅仅是一个重大的事件， 六级标题还可能会改变我的人生。 六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题六级标题"},{"title":"这是一段很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长的文章","date":"2020-04-11T15:53:28.000Z","url":"/2020/04/11/longtext/","tags":[["Example","/tags/Example/"]],"categories":[["例子","/categories/%E4%BE%8B%E5%AD%90/"]],"content":"这儿是大段文本示例~ 如果在 hexo serve --debug 下运行，会看到这篇文章无法全部渲染。这是由热重载插件 hexo-browsersync 导致的，不会影响发布。 这是一段很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长的文章德国曾经提到过，只有在人群中间，才能认识自己。我希望诸位也能好好地体会这句话。 既然如此， 既然如何， 而这些并不是完全重要，更加重要的问题是， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 可是，即使是这样，这一大段文章的出现仍然代表了一定的意义。 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 塞涅卡曾经说过，生命如同寓言，其价值不在与长短，而在与内容。这似乎解答了我的疑惑。 既然如此， 可是，即使是这样，这一大段文章的出现仍然代表了一定的意义。 这一大段文章因何而发生？ 杰纳勒尔·乔治·S·巴顿曾经提到过，接受挑战，就可以享受胜利的喜悦。带着这句话，我们还要更加慎重的审视这个问题： 从这个角度来看， 带着这些问题，我们来审视一下这一大段文章。 卢梭说过一句富有哲理的话，浪费时间是一桩大罪过。这似乎解答了我的疑惑。 了解清楚这一大段文章到底是一种怎么样的存在，是解决一切问题的关键。 一般来讲，我们都必须务必慎重的考虑考虑。 我们不得不面对一个非常尴尬的事实，那就是， 这样看来， 生活中，若这一大段文章出现了，我们就不得不考虑它出现了的事实。 一般来讲，我们都必须务必慎重的考虑考虑。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 这一大段文章，发生了会如何，不发生又会如何。 了解清楚这一大段文章到底是一种怎么样的存在，是解决一切问题的关键。 既然如何， 从这个角度来看， 从这个角度来看， 我认为， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 那么。 这样看来， 经过上述讨论， 而这些并不是完全重要，更加重要的问题是， 就我个人来说，这一大段文章对我的意义，不能不说非常重大。 德谟克利特曾经说过，节制使快乐增加并使享受加强。这不禁令我深思。 生活中，若这一大段文章出现了，我们就不得不考虑它出现了的事实。 经过上述讨论， 塞涅卡说过一句富有哲理的话，真正的人生，只有在经过艰难卓绝的斗争之后才能实现。我希望诸位也能好好地体会这句话。 我认为， 这一大段文章的发生，到底需要如何做到，不这一大段文章的发生，又会如何产生。 现在，解决这一大段文章的问题，是非常非常重要的。 所以， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 在这种困难的抉择下，本人思来想去，寝食难安。 这一大段文章因何而发生？ 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 我们不得不面对一个非常尴尬的事实，那就是， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 这一大段文章的发生，到底需要如何做到，不这一大段文章的发生，又会如何产生。 贝多芬曾经说过，卓越的人一大优点是：在不利与艰难的遭遇里百折不饶。我希望诸位也能好好地体会这句话。 这一大段文章因何而发生？ 现在，解决这一大段文章的问题，是非常非常重要的。 所以， 对我个人而言，这一大段文章不仅仅是一个重大的事件，还可能会改变我的人生。 屠格涅夫在不经意间这样说过，你想成为幸福的人吗？但愿你首先学会吃得起苦。这不禁令我深思。 一般来讲，我们都必须务必慎重的考虑考虑。 那么， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 这一大段文章的发生，到底需要如何做到，不这一大段文章的发生，又会如何产生。 问题的关键究竟为何。 王阳明说过一句富有哲理的话，故立志者，为学之心也；为学者，立志之事也。这句话语虽然很短，但令我浮想联翩。 而这些并不是完全重要，更加重要的问题是， 歌德曾经说过，没有人事先了解自己到底有多大的力量，直到他试过以后才知道。这似乎解答了我的疑惑。 这一大段文章因何而发生？ 要想清楚，这一大段文章，到底是一种怎么样的存在。 对我个人而言，这一大段文章不仅仅是一个重大的事件，还可能会改变我的人生。 既然如何， 而这些并不是完全重要，更加重要的问题是， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 我们都知道，只要有意义，那么就必须慎重考虑。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 既然如何， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 歌德曾经说过，决定一个人的一生，以及整个命运的，只是一瞬之间。这句话语虽然很短，但令我浮想联翩。 我们都知道，只要有意义，那么就必须慎重考虑。 要想清楚，这一大段文章，到底是一种怎么样的存在。 每个人都不得不面对这些问题。 在面对这种问题时， 这样看来， 现在，解决这一大段文章的问题，是非常非常重要的。 所以， 对我个人而言，这一大段文章不仅仅是一个重大的事件，还可能会改变我的人生。 所谓这一大段文章，关键是这一大段文章需要如何写。 这一大段文章，发生了会如何，不发生又会如何。 现在，解决这一大段文章的问题，是非常非常重要的。 所以， 而这些并不是完全重要，更加重要的问题是， 这一大段文章，到底应该如何实现。 既然如何， 一般来说， 对我个人而言，这一大段文章不仅仅是一个重大的事件，还可能会改变我的人生。 问题的关键究竟为何？ 那么， 就我个人来说，这一大段文章对我的意义，不能不说非常重大。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 这样看来， 我们都知道，只要有意义，那么就必须慎重考虑。 莎士比亚在不经意间这样说过，抛弃时间的人，时间也抛弃他。这似乎解答了我的疑惑。 而这些并不是完全重要，更加重要的问题是， 亚伯拉罕·林肯曾经说过，我这个人走得很慢，但是我从不后退。我希望诸位也能好好地体会这句话。 我们不得不面对一个非常尴尬的事实，那就是， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 从这个角度来看， 可是，即使是这样，这一大段文章的出现仍然代表了一定的意义。 这一大段文章的发生，到底需要如何做到，不这一大段文章的发生，又会如何产生。 要想清楚，这一大段文章，到底是一种怎么样的存在。 一般来讲，我们都必须务必慎重的考虑考虑。 歌德曾经提到过，读一本好书，就如同和一个高尚的人在交谈。我希望诸位也能好好地体会这句话。 每个人都不得不面对这些问题。 在面对这种问题时， 总结的来说， 就我个人来说，这一大段文章对我的意义，不能不说非常重大。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 我们都知道，只要有意义，那么就必须慎重考虑。 就我个人来说，这一大段文章对我的意义，不能不说非常重大。 生活中，若这一大段文章出现了，我们就不得不考虑它出现了的事实。 而这些并不是完全重要，更加重要的问题是。 而这些并不是完全重要，更加重要的问题是， 这样看来， 米歇潘说过一句富有哲理的话，生命是一条艰险的峡谷，只有勇敢的人才能通过。带着这句话，我们还要更加慎重的审视这个问题： 苏轼说过一句富有哲理的话，古之立大事者，不惟有超世之才，亦必有坚忍不拔之志。这启发了我， 这样看来， 我们不得不面对一个非常尴尬的事实，那就是， 既然如此， 经过上述讨论， 雷锋在不经意间这样说过，自己活着，就是为了使别人过得更美好。这似乎解答了我的疑惑。 这样看来， 这一大段文章，发生了会如何，不发生又会如何。 对我个人而言，这一大段文章不仅仅是一个重大的事件，还可能会改变我的人生。 对我个人而言，这一大段文章不仅仅是一个重大的事件，还可能会改变我的人生。 带着这些问题，我们来审视一下这一大段文章。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 伏尔泰曾经提到过，不经巨大的困难，不会有伟大的事业。我希望诸位也能好好地体会这句话。 这一大段文章，发生了会如何，不发生又会如何。 每个人都不得不面对这些问题。 在面对这种问题时， 文森特·皮尔曾经说过，改变你的想法，你就改变了自己的世界。这不禁令我深思。 总结的来说， 这一大段文章的发生，到底需要如何做到，不这一大段文章的发生，又会如何产生。 可是，即使是这样，这一大段文章的出现仍然代表了一定的意义。 这一大段文章，到底应该如何实现。 总结的来说， 生活中，若这一大段文章出现了，我们就不得不考虑它出现了的事实。 我们不得不面对一个非常尴尬的事实，那就是， 带着这些问题，我们来审视一下这一大段文章。 鲁巴金说过一句富有哲理的话，读书是在别人思想的帮助下，建立起自己的思想。这似乎解答了我的疑惑。 既然如此， 就我个人来说，这一大段文章对我的意义，不能不说非常重大。 杰纳勒尔·乔治·S·巴顿在不经意间这样说过，接受挑战，就可以享受胜利的喜悦。这句话语虽然很短，但令我浮想联翩。 这一大段文章，到底应该如何实现。 这一大段文章因何而发生？ 可是，即使是这样，这一大段文章的出现仍然代表了一定的意义。 这一大段文章，到底应该如何实现。 这一大段文章的发生，到底需要如何做到，不这一大段文章的发生，又会如何产生。 所谓这一大段文章，关键是这一大段文章需要如何写。 要想清楚，这一大段文章，到底是一种怎么样的存在。 就我个人来说，这一大段文章对我的意义，不能不说非常重大。 问题的关键究竟为何？ 从这个角度来看， 问题的关键究竟为何？ 一般来讲，我们都必须务必慎重的考虑考虑。 所谓这一大段文章，关键是这一大段文章需要如何写。 对我个人而言，这一大段文章不仅仅是一个重大的事件，还可能会改变我的人生。 塞涅卡曾经说过，生命如同寓言，其价值不在与长短，而在与内容。这不禁令我深思。 我们不得不面对一个非常尴尬的事实，那就是， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 这样看来， 可是，即使是这样，这一大段文章的出现仍然代表了一定的意义。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 一般来说， 现在，解决这一大段文章的问题，是非常非常重要的。 所以， 我们都知道，只要有意义，那么就必须慎重考虑。 那么， 了解清楚这一大段文章到底是一种怎么样的存在，是解决一切问题的关键。 一般来讲，我们都必须务必慎重的考虑考虑。 而这些并不是完全重要，更加重要的问题是， 老子说过一句富有哲理的话，知人者智，自知者明。胜人者有力，自胜者强。这启发了我， 一般来说， 这一大段文章的发生，到底需要如何做到，不这一大段文章的发生，又会如何产生。 文森特·皮尔曾经提到过，改变你的想法，你就改变了自己的世界。我希望诸位也能好好地体会这句话。 那么， 在这种困难的抉择下，本人思来想去，寝食难安。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 一般来讲，我们都必须务必慎重的考虑考虑。 乌申斯基说过一句富有哲理的话，学习是劳动，是充满思想的劳动。这启发了我， 卢梭曾经提到过，浪费时间是一桩大罪过。这不禁令我深思。 博曾经提到过，一次失败，只是证明我们成功的决心还够坚强。 维这启发了我， 我认为， 现在，解决这一大段文章的问题，是非常非常重要的。 所以， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 要想清楚，这一大段文章，到底是一种怎么样的存在。 这样看来， 我认为， 我们都知道，只要有意义，那么就必须慎重考虑。 经过上述讨论， 我认为， 总结的来说， 非洲曾经提到过，最灵繁的人也看不见自己的背脊。这不禁令我深思。 这一大段文章的发生，到底需要如何做到，不这一大段文章的发生，又会如何产生。 就我个人来说，这一大段文章对我的意义，不能不说非常重大。 这一大段文章因何而发生？ 了解清楚这一大段文章到底是一种怎么样的存在，是解决一切问题的关键。 对我个人而言，这一大段文章不仅仅是一个重大的事件，还可能会改变我的人生。 希腊在不经意间这样说过，最困难的事情就是认识自己。我希望诸位也能好好地体会这句话。 从这个角度来看， 这一大段文章，到底应该如何实现。 可是，即使是这样，这一大段文章的出现仍然代表了一定的意义。 既然如何， 对我个人而言，这一大段文章不仅仅是一个重大的事件，还可能会改变我的人生。 了解清楚这一大段文章到底是一种怎么样的存在，是解决一切问题的关键。 生活中，若这一大段文章出现了，我们就不得不考虑它出现了的事实。 一般来说， 一般来说， 莫扎特曾经提到过，谁和我一样用功，谁就会和我一样成功。这启发了我， 一般来讲，我们都必须务必慎重的考虑考虑。 就我个人来说，这一大段文章对我的意义，不能不说非常重大。 一般来讲，我们都必须务必慎重的考虑考虑。 这一大段文章因何而发生？ 经过上述讨论， 一般来说， 一般来讲，我们都必须务必慎重的考虑考虑。 亚伯拉罕·林肯曾经提到过，你活了多少岁不算什么，重要的是你是如何度过这些岁月的。带着这句话，我们还要更加慎重的审视这个问题： 就我个人来说，这一大段文章对我的意义，不能不说非常重大。 现在，解决这一大段文章的问题，是非常非常重要的。 所以， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 从这个角度来看， 可是，即使是这样，这一大段文章的出现仍然代表了一定的意义。 了解清楚这一大段文章到底是一种怎么样的存在，是解决一切问题的关键。 要想清楚，这一大段文章，到底是一种怎么样的存在。 所谓这一大段文章，关键是这一大段文章需要如何写。 左拉说过一句富有哲理的话，生活的道路一旦选定，就要勇敢地走到底，决不回头。这启发了我， 现在，解决这一大段文章的问题，是非常非常重要的。 所以， 一般来讲，我们都必须务必慎重的考虑考虑。 我认为， 对我个人而言，这一大段文章不仅仅是一个重大的事件，还可能会改变我的人生。 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下这一大段文章。 每个人都不得不面对这些问题。 在面对这种问题时， 所谓这一大段文章，关键是这一大段文章需要如何写。 总结的来说， 这一大段文章，发生了会如何，不发生又会如何。 别林斯基说过一句富有哲理的话，好的书籍是最贵重的珍宝。我希望诸位也能好好地体会这句话。 每个人都不得不面对这些问题。 在面对这种问题时， 贝多芬曾经提到过，卓越的人一大优点是：在不利与艰难的遭遇里百折不饶。这启发了我， 从这个角度来看， 既然如此， 这一大段文章因何而发生？ 而这些并不是完全重要，更加重要的问题是， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 对我个人而言，这一大段文章不仅仅是一个重大的事件，还可能会改变我的人生。 所谓这一大段文章，关键是这一大段文章需要如何写。 维龙曾经说过，要成功不需要什么特别的才能，只要把你能做的小事做得好就行了。这不禁令我深思。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 这一大段文章因何而发生？ 这一大段文章，到底应该如何实现。 这样看来， 对我个人而言，这一大段文章不仅仅是一个重大的事件，还可能会改变我的人生。 黑格尔说过一句富有哲理的话，只有永远躺在泥坑里的人，才不会再掉进坑里。这启发了我， 可是，即使是这样，这一大段文章的出现仍然代表了一定的意义。 笛卡儿在不经意间这样说过，读一切好书，就是和许多高尚的人谈话。我希望诸位也能好好地体会这句话。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 叔本华说过一句富有哲理的话，意志是一个强壮的盲人，倚靠在明眼的跛子肩上。这句话语虽然很短，但令我浮想联翩。 这一大段文章，到底应该如何实现。 卡耐基曾经说过，一个不注意小事情的人，永远不会成就大事业。这似乎解答了我的疑惑。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 就我个人来说，这一大段文章对我的意义，不能不说非常重大。 带着这些问题，我们来审视一下这一大段文章。 那么， 这一大段文章的发生，到底需要如何做到，不这一大段文章的发生，又会如何产生。 既然如此， 可是，即使是这样，这一大段文章的出现仍然代表了一定的意义。 在这种困难的抉择下，本人思来想去，寝食难安。 这一大段文章的发生，到底需要如何做到，不这一大段文章的发生，又会如何产生。 问题的关键究竟为何？ 既然如何， 生活中，若这一大段文章出现了，我们就不得不考虑它出现了的事实。 这一大段文章因何而发生。 要想清楚，这一大段文章，到底是一种怎么样的存在。 一般来讲，我们都必须务必慎重的考虑考虑。 生活中，若这一大段文章出现了，我们就不得不考虑它出现了的事实。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 现在，解决这一大段文章的问题，是非常非常重要的。 所以， 这一大段文章的发生，到底需要如何做到，不这一大段文章的发生，又会如何产生。 别林斯基在不经意间这样说过，好的书籍是最贵重的珍宝。我希望诸位也能好好地体会这句话。 这一大段文章的发生，到底需要如何做到，不这一大段文章的发生，又会如何产生。 每个人都不得不面对这些问题。 在面对这种问题时， 我们都知道，只要有意义，那么就必须慎重考虑。 培根说过一句富有哲理的话，要知道对好事的称颂过于夸大，也会招来人们的反感轻蔑和嫉妒。这不禁令我深思。 这一大段文章的发生，到底需要如何做到，不这一大段文章的发生，又会如何产生。 我认为， 要想清楚，这一大段文章，到底是一种怎么样的存在。 这一大段文章，到底应该如何实现。 对我个人而言，这一大段文章不仅仅是一个重大的事件，还可能会改变我的人生。 我认为， 就我个人来说，这一大段文章对我的意义，不能不说非常重大。 经过上述讨论， 在这种困难的抉择下，本人思来想去，寝食难安。 总结的来说， 我们不得不面对一个非常尴尬的事实，那就是， 现在，解决这一大段文章的问题，是非常非常重要的。 所以， 要想清楚，这一大段文章，到底是一种怎么样的存在。 我认为， 这一大段文章，发生了会如何，不发生又会如何。 在这种困难的抉择下，本人思来想去，寝食难安。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 现在，解决这一大段文章的问题，是非常非常重要的。 所以， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 了解清楚这一大段文章到底是一种怎么样的存在，是解决一切问题的关键。 俾斯麦曾经提到过，失败是坚忍的最后考验。这不禁令我深思。 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 总结的来说， 问题的关键究竟为何？ 我们都知道，只要有意义，那么就必须慎重考虑。 这样看来， 这一大段文章，到底应该如何实现。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 富勒曾经提到过，苦难磨炼一些人，也毁灭另一些人。这句话语虽然很短，但令我浮想联翩。 吕凯特曾经说过，生命不可能有两次，但许多人连一次也不善于度过。这句话语虽然很短，但令我浮想联翩。 可是，即使是这样，这一大段文章的出现仍然代表了一定的意义。 既然如此， 而这些并不是完全重要，更加重要的问题是， 培根曾经说过，深窥自己的心，而后发觉一切的奇迹在你自己。这句话语虽然很短，但令我浮想联翩。 每个人都不得不面对这些问题。 在面对这种问题时， 现在，解决这一大段文章的问题，是非常非常重要的。 所以， 既然如何， 现在，解决这一大段文章的问题，是非常非常重要的。 所以， 我们不得不面对一个非常尴尬的事实，那就是， 王阳明曾经说过，故立志者，为学之心也；为学者，立志之事也。这句话语虽然很短，但令我浮想联翩。 富兰克林说过一句富有哲理的话，你热爱生命吗？那么别浪费时间，因为时间是组成生命的材料。这句话语虽然很短，但令我浮想联翩。 这一大段文章的发生，到底需要如何做到，不这一大段文章的发生，又会如何产生。 斯宾诺莎在不经意间这样说过，最大的骄傲于最大的自卑都表示心灵的最软弱无力。这不禁令我深思。 西班牙在不经意间这样说过，自知之明是最难得的知识。这不禁令我深思。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 带着这些问题，我们来审视一下这一大段文章。 那么， 王阳明曾经提到过，故立志者，为学之心也；为学者，立志之事也。我希望诸位也能好好地体会这句话。 每个人都不得不面对这些问题。 在面对这种问题时， 既然如此， 在这种困难的抉择下，本人思来想去，寝食难安。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 我们不得不面对一个非常尴尬的事实，那就是， 所谓这一大段文章，关键是这一大段文章需要如何写。 那么， 一般来讲，我们都必须务必慎重的考虑考虑。 经过上述讨论， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 可是，即使是这样，这一大段文章的出现仍然代表了一定的意义。 那么， 总结的来说， 这一大段文章因何而发生？ 所谓这一大段文章，关键是这一大段文章需要如何写。 在这种困难的抉择下，本人思来想去，寝食难安。 吉格·金克拉曾经说过，如果你能做梦，你就能实现它。这句话语虽然很短，但令我浮想联翩。 我们不得不面对一个非常尴尬的事实，那就是。 就我个人来说，这一大段文章对我的意义，不能不说非常重大。 问题的关键究竟为何？ 现在，解决这一大段文章的问题，是非常非常重要的。 所以， 现在，解决这一大段文章的问题，是非常非常重要的。 所以， 这一大段文章，发生了会如何，不发生又会如何。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 所谓这一大段文章，关键是这一大段文章需要如何写。 德国在不经意间这样说过，只有在人群中间，才能认识自己。我希望诸位也能好好地体会这句话。 对我个人而言，这一大段文章不仅仅是一个重大的事件，还可能会改变我的人生。 了解清楚这一大段文章到底是一种怎么样的存在，是解决一切问题的关键。 总结的来说， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 对我个人而言，这一大段文章不仅仅是一个重大的事件，还可能会改变我的人生。 了解清楚这一大段文章到底是一种怎么样的存在，是解决一切问题的关键。 所谓这一大段文章，关键是这一大段文章需要如何写。 歌德在不经意间这样说过，决定一个人的一生，以及整个命运的，只是一瞬之间。带着这句话，我们还要更加慎重的审视这个问题： 经过上述讨论。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 既然如此， 笛卡儿在不经意间这样说过，我的努力求学没有得到别的好处，只不过是愈来愈发觉自己的无知。这启发了我， 孔子说过一句富有哲理的话，知之者不如好之者，好之者不如乐之者。我希望诸位也能好好地体会这句话。 这一大段文章，发生了会如何，不发生又会如何。 那么， 了解清楚这一大段文章到底是一种怎么样的存在，是解决一切问题的关键。 了解清楚这一大段文章到底是一种怎么样的存在，是解决一切问题的关键。 对我个人而言，这一大段文章不仅仅是一个重大的事件，还可能会改变我的人生。 在这种困难的抉择下，本人思来想去，寝食难安。 这一大段文章因何而发生？ 从这个角度来看， 带着这些问题，我们来审视一下这一大段文章。 生活中，若这一大段文章出现了，我们就不得不考虑它出现了的事实。 生活中，若这一大段文章出现了，我们就不得不考虑它出现了的事实。 我们都知道，只要有意义，那么就必须慎重考虑。 经过上述讨论， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 生活中，若这一大段文章出现了，我们就不得不考虑它出现了的事实。 这一大段文章，到底应该如何实现。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是， 那么， 一般来讲，我们都必须务必慎重的考虑考虑。 要想清楚，这一大段文章，到底是一种怎么样的存在。 所谓这一大段文章，关键是这一大段文章需要如何写。 既然如何， 在这种困难的抉择下，本人思来想去，寝食难安。 生活中，若这一大段文章出现了，我们就不得不考虑它出现了的事实。 吕凯特曾经说过，生命不可能有两次，但许多人连一次也不善于度过。这似乎解答了我的疑惑。 这样看来， 美华纳曾经说过，勿问成功的秘诀为何，且尽全力做你应该做的事吧。这似乎解答了我的疑惑。 我们不得不面对一个非常尴尬的事实，那就是， 问题的关键究竟为何？ 这一大段文章，到底应该如何实现。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 在这种困难的抉择下，本人思来想去，寝食难安。 我们都知道，只要有意义，那么就必须慎重考虑。 洛克曾经说过，学到很多东西的诀窍，就是一下子不要学很多。这启发了我， 既然如此， 所谓这一大段文章，关键是这一大段文章需要如何写。 冯学峰曾经说过，当一个人用工作去迎接光明，光明很快就会来照耀着他。这句话语虽然很短，但令我浮想联翩。 这一大段文章，发生了会如何，不发生又会如何。 博曾经说过，一次失败，只是证明我们成功的决心还够坚强。 维这启发了我， 我们都知道，只要有意义，那么就必须慎重考虑。 这一大段文章，到底应该如何实现。 我们不得不面对一个非常尴尬的事实，那就是， 生活中，若这一大段文章出现了，我们就不得不考虑它出现了的事实。 这一大段文章的发生，到底需要如何做到，不这一大段文章的发生，又会如何产生。 而这些并不是完全重要，更加重要的问题是， 了解清楚这一大段文章到底是一种怎么样的存在，是解决一切问题的关键。 带着这些问题，我们来审视一下这一大段文章。 所谓这一大段文章，关键是这一大段文章需要如何写。 要想清楚，这一大段文章，到底是一种怎么样的存在。 要想清楚，这一大段文章，到底是一种怎么样的存在。 在这种困难的抉择下，本人思来想去，寝食难安。 我认为， 要想清楚，这一大段文章，到底是一种怎么样的存在。 带着这些问题，我们来审视一下这一大段文章。 问题的关键究竟为何？ 问题的关键究竟为何？ 这一大段文章，发生了会如何，不发生又会如何。 一般来说， 现在，解决这一大段文章的问题，是非常非常重要的。 所以， 经过上述讨论， 郭沫若曾经说过，形成天才的决定因素应该是勤奋。这句话语虽然很短，但令我浮想联翩。 这一大段文章，发生了会如何，不发生又会如何。 就我个人来说，这一大段文章对我的意义，不能不说非常重大。 一般来说， 所谓这一大段文章，关键是这一大段文章需要如何写。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 那么， 我们都知道，只要有意义，那么就必须慎重考虑。 既然如何， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 要想清楚，这一大段文章，到底是一种怎么样的存在。 亚伯拉罕·林肯曾经提到过，我这个人走得很慢，但是我从不后退。这似乎解答了我的疑惑。 我们都知道，只要有意义，那么就必须慎重考虑。 这样看来， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我们不得不面对一个非常尴尬的事实，那就是， 带着这些问题，我们来审视一下这一大段文章。 所谓这一大段文章，关键是这一大段文章需要如何写。 这一大段文章的发生，到底需要如何做到，不这一大段文章的发生，又会如何产生。 这样看来， 而这些并不是完全重要，更加重要的问题是， 就我个人来说，这一大段文章对我的意义，不能不说非常重大。 我认为， 既然如何， 布尔沃曾经说过，要掌握书，莫被书掌握；要为生而读，莫为读而生。带着这句话，我们还要更加慎重的审视这个问题： 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 那么， 那么， 我们不得不面对一个非常尴尬的事实，那就是， 了解清楚这一大段文章到底是一种怎么样的存在，是解决一切问题的关键。 日本谚语曾经说过，不幸可能成为通向幸福的桥梁。带着这句话，我们还要更加慎重的审视这个问题： 邓拓曾经提到过，越是没有本领的就越加自命不凡。这不禁令我深思。 既然如何， 一般来说， 对我个人而言，这一大段文章不仅仅是一个重大的事件，还可能会改变我的人生。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 从这个角度来看， 在这种困难的抉择下，本人思来想去，寝食难安。 既然如何， 这一大段文章因何而发生？ 莎士比亚说过一句富有哲理的话，人的一生是短的，但如果卑劣地过这一生，就太长了。我希望诸位也能好好地体会这句话。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 既然如此， 史美尔斯在不经意间这样说过，书籍把我们引入最美好的社会，使我们认识各个时代的伟大智者。带着这句话，我们还要更加慎重的审视这个问题： 维龙在不经意间这样说过，要成功不需要什么特别的才能，只要把你能做的小事做得好就行了。这不禁令我深思。 这样看来， 非洲曾经提到过，最灵繁的人也看不见自己的背脊。这启发了我。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 这样看来， 经过上述讨论， 富勒曾经说过，苦难磨炼一些人，也毁灭另一些人。这句话语虽然很短，但令我浮想联翩。 那么， 池田大作曾经说过，不要回避苦恼和困难，挺起身来向它挑战，进而克服它。这启发了我， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 对我个人而言，这一大段文章不仅仅是一个重大的事件，还可能会改变我的人生。 培根曾经说过，阅读使人充实，会谈使人敏捷，写作使人精确。带着这句话，我们还要更加慎重的审视这个问题： 总结的来说。 笛卡儿曾经提到过，阅读一切好书如同和过去最杰出的人谈话。这似乎解答了我的疑惑。 在这种困难的抉择下，本人思来想去，寝食难安。"}]
<!DOCTYPE html>
<html lang="jp">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  <link rel="icon" href="">
  <title>kotlin 基本类型 | 凌</title>
  <meta name="author" content="Yue_plus" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="Conclusion" />
  
  <meta name="description" content="基本类型在 Kotlin 中，所有东西都是对象，在这个意义上讲我们可以在任何变量上调用成员函数与属性。一些类型可以有特殊的内部表示——例如，数字、字符以及布尔值可以在运行时表示为原生类型值，但是对于用户来说，它们看起来就像普通的类。在本节中，我们会描述 Kotlin 中使用的基本类型：数字、字符、布尔值、数组与字符串。">
<meta property="og:type" content="article">
<meta property="og:title" content="kotlin 基本类型">
<meta property="og:url" content="http://example.com/2020/07/14/kotlin%20%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/index.html">
<meta property="og:site_name" content="凌">
<meta property="og:description" content="基本类型在 Kotlin 中，所有东西都是对象，在这个意义上讲我们可以在任何变量上调用成员函数与属性。一些类型可以有特殊的内部表示——例如，数字、字符以及布尔值可以在运行时表示为原生类型值，但是对于用户来说，它们看起来就像普通的类。在本节中，我们会描述 Kotlin 中使用的基本类型：数字、字符、布尔值、数组与字符串。">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/null">
<meta property="article:published_time" content="2020-07-14T00:34:40.000Z">
<meta property="article:modified_time" content="2021-04-10T03:04:09.073Z">
<meta property="article:author" content="Yue_plus">
<meta property="article:tag" content="Conclusion">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/null">
<meta name="twitter:site" content="@null">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" type="text/css" media="all">
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" type="text/css" media="all">
  
  
  <link rel="stylesheet" id="fontawe-css" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" type="text/css" media="all">
  <link rel="stylesheet" id="nprogress-css" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" type="text/css" media="all">
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-dark.min.css" type="text/css" media="all">
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="https://cdn.jsdelivr.net/npm/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
      .kratos-cover.kratos-cover-2 {
        background-image: url('/images/banner.webp');
      }
    
    
      @media(min-width:768px) {
        body.custom-background {
          background-image: url('/images/bg.webp');
        }
      }
    
  </style>
  
<meta name="generator" content="Hexo 5.3.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                        <li><a href="/"><i class="fa fa-home"></i>首页</a></li>
                                    
                                
                                    
                                        <li><a href="/archives/"><i class="fa fa-file"></i>档案馆</a></li>
                                    
                                
                                    
                                        <li><a href="/friends/"><i class="fa fa-paw"></i>好伙伴</a></li>
                                    
                                
                                    
                                        <li>
                                            <a><i class="fa fa-link"></i>链接</a>
                                            <ul class="sub-menu">
                                                
                                                    
                                                
                                                    
                                                        <li><a target="_blank" rel="noopener" href="https://candinya.com">作者博客</a></li>
                                                    
                                                
                                                    
                                                        <li><a target="_blank" rel="noopener" href="https://github.com/Candinya/Kratos-Rebirth">项目链接</a></li>
                                                    
                                                
                                            </ul>
                                        </li>
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">凌</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>凌</h2> <br />
                        <span></span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article>
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center">kotlin 基本类型</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><i class="fa fa-calendar"></i> 2020-07-14</li>
                <li><i class="fa fa-user"></i> 作者 Yue_plus</li>
                <li>
                    <i class="fa fa-edit"></i> 
                    
                    
                        ~9.38K
                    
                    字
                </li>
                
            </ul>
        </header>
        <div class="kratos-post-content">
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                本文最后编辑于 <time datetime="1618023849073"></time> 前，其中的内容可能需要更新。
            </div>
            
            <hr />
            <h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><p>在 Kotlin 中，所有东西都是对象，在这个意义上讲我们可以在任何变量上调用成员函数与属性。<br>一些类型可以有特殊的内部表示——例如，数字、字符以及布尔值可以在运行时表示为原生类型值，但是对于用户来说，它们看起来就像普通的类。<br>在本节中，我们会描述 Kotlin 中使用的基本类型：数字、字符、布尔值、数组与字符串。</p>
<a id="more"></a>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.kotlincn.net/docs/reference/basic-types.html">原文地址</a>，此处仅作展示！</p>
</blockquote>
<h1 id="基本类型-1"><a href="#基本类型-1" class="headerlink" title="基本类型"></a>基本类型</h1><p>在 Kotlin 中，所有东西都是对象，在这个意义上讲我们可以在任何变量上调用成员函数与属性。<br>一些类型可以有特殊的内部表示——例如，数字、字符以及布尔值可以在运行时表示为原生类型值，但是对于用户来说，它们看起来就像普通的类。<br>在本节中，我们会描述 Kotlin 中使用的基本类型：数字、字符、布尔值、数组与字符串。</p>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>Kotlin 提供了一组表示数字的内置类型。<br>对于整数，有四种不同大小的类型，因此值的范围也不同。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小（比特数）</th>
<th>最小值</th>
<th>最大值</th>
</tr>
</thead>
<tbody><tr>
<td>Byte</td>
<td>8</td>
<td>-128</td>
<td>127</td>
</tr>
<tr>
<td>Short</td>
<td>16</td>
<td>-32768</td>
<td>32767</td>
</tr>
<tr>
<td>Int</td>
<td>32</td>
<td>-2,147,483,648 (-2<sup>31</sup>)</td>
<td>2,147,483,647 (2<sup>31</sup> - 1)</td>
</tr>
<tr>
<td>Long</td>
<td>64</td>
<td>-9,223,372,036,854,775,808 (-2<sup>63</sup>)</td>
<td>9,223,372,036,854,775,807 (2<sup>63</sup> - 1)</td>
</tr>
</tbody></table>
<p>所有以未超出 <code>Int</code> 最大值的整型值初始化的变量都会推断为 <code>Int</code> 类型。如果初始值超过了其最大值，那么推断为 <code>Long</code> 类型。<br>如需显式指定 <code>Long</code> 型值，请在该值后追加 <code>L</code> 后缀。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> one = <span class="number">1</span> <span class="comment">// Int</span></span><br><span class="line"><span class="keyword">val</span> threeBillion = <span class="number">3000000000</span> <span class="comment">// Long</span></span><br><span class="line"><span class="keyword">val</span> oneLong = <span class="number">1L</span> <span class="comment">// Long</span></span><br><span class="line"><span class="keyword">val</span> oneByte: <span class="built_in">Byte</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>对于浮点数，Kotlin 提供了 <code>Float</code> 与 <code>Double</code> 类型。<br>根据 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IEEE_754">IEEE 754 标准</a>，<br>两种浮点类型的<em>十进制位数</em>（即可以存储多少位十进制数）不同。<br><code>Float</code> 反映了 IEEE 754 <em>单精度</em>，而 <code>Double</code> 提供了<em>双精度</em>。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小（比特数）</th>
<th>有效数字比特数</th>
<th>指数比特数</th>
<th>十进制位数</th>
</tr>
</thead>
<tbody><tr>
<td>Float</td>
<td>32</td>
<td>24</td>
<td>8</td>
<td>6-7</td>
</tr>
<tr>
<td>Double</td>
<td>64</td>
<td>53</td>
<td>11</td>
<td>15-16</td>
</tr>
<tr>
<td>对于以小数初始化的变量，编译器会推断为 <code>Double</code> 类型。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>如需将一个值显式指定为 <code>Float</code> 类型，请添加 <code>f</code> 或 <code>F</code> 后缀。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>如果这样的值包含多于 6～7 位十进制数，那么会将其舍入。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> pi = <span class="number">3.14</span> <span class="comment">// Double</span></span><br><span class="line"><span class="keyword">val</span> e = <span class="number">2.7182818284</span> <span class="comment">// Double</span></span><br><span class="line"><span class="keyword">val</span> eFloat = <span class="number">2.7182818284f</span> <span class="comment">// Float，实际值为 2.7182817</span></span><br></pre></td></tr></table></figure>
<p>请注意，与一些其他语言不同，Kotlin 中的数字没有隐式拓宽转换。<br>例如，具有 <code>Double</code> 参数的函数只能对 <code>Double</code> 值调用，而不能对 <code>Float</code>、<br><code>Int</code> 或者其他数字值调用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printDouble</span><span class="params">(d: <span class="type">Double</span>)</span></span> &#123; print(d) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> i = <span class="number">1</span>    </span><br><span class="line">    <span class="keyword">val</span> d = <span class="number">1.1</span></span><br><span class="line">    <span class="keyword">val</span> f = <span class="number">1.1f</span> </span><br><span class="line"></span><br><span class="line">    printDouble(d)</span><br><span class="line"><span class="comment">//    printDouble(i) // 错误：类型不匹配</span></span><br><span class="line"><span class="comment">//    printDouble(f) // 错误：类型不匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如需将数值转换为不同的类型，请使用<a href="#%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2">显示转换</a>。</p>
<h3 id="字面常量"><a href="#字面常量" class="headerlink" title="字面常量"></a>字面常量</h3><p>数值常量字面值有以下几种:</p>
<ul>
<li>十进制: <code>123</code><ul>
<li>Long 类型用大写 <code>L</code> 标记: <code>123L</code></li>
</ul>
</li>
<li>十六进制: <code>0x0F</code></li>
<li>二进制: <code>0b00001011</code></li>
</ul>
<p>注意: 不支持八进制</p>
<p>Kotlin 同样支持浮点数的常规表示方法:</p>
<ul>
<li><p>默认 double：<code>123.5</code>、<code>123.5e10</code></p>
</li>
<li><p>Float 用 <code>f</code> 或者 <code>F</code> 标记: <code>123.5f</code></p>
<h3 id="数字字面值中的下划线（自-1-1-起）"><a href="#数字字面值中的下划线（自-1-1-起）" class="headerlink" title="数字字面值中的下划线（自 1.1 起）"></a>数字字面值中的下划线（自 1.1 起）</h3><p>你可以使用下划线使数字常量更易读：</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> oneMillion = <span class="number">1_000_000</span></span><br><span class="line"><span class="keyword">val</span> creditCardNumber = <span class="number">1234_5678_9012_3456L</span></span><br><span class="line"><span class="keyword">val</span> socialSecurityNumber = <span class="number">999_99_9999L</span></span><br><span class="line"><span class="keyword">val</span> hexBytes = <span class="number">0xFF_EC_DE_5E</span></span><br><span class="line"><span class="keyword">val</span> bytes = <span class="number">0b11010010_01101001_10010100_10010010</span></span><br></pre></td></tr></table></figure>
<h3 id="表示方式"><a href="#表示方式" class="headerlink" title="表示方式"></a>表示方式</h3><p>在 Java 平台数字是物理存储为 JVM 的原生类型，除非我们需要一个可空的引用（如 <code>Int?</code>）或泛型。<br>后者情况下会把数字装箱。</p>
<p>注意数字装箱不一定保留同一性:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">100</span></span><br><span class="line">    <span class="keyword">val</span> boxedA: <span class="built_in">Int</span>? = a</span><br><span class="line">    <span class="keyword">val</span> anotherBoxedA: <span class="built_in">Int</span>? = a</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> b: <span class="built_in">Int</span> = <span class="number">10000</span></span><br><span class="line">    <span class="keyword">val</span> boxedB: <span class="built_in">Int</span>? = b</span><br><span class="line">    <span class="keyword">val</span> anotherBoxedB: <span class="built_in">Int</span>? = b</span><br><span class="line">    </span><br><span class="line">    println(boxedA === anotherBoxedA) <span class="comment">// true</span></span><br><span class="line">    println(boxedB === anotherBoxedB) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一方面，它保留了相等性:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">10000</span></span><br><span class="line">    println(a == a) <span class="comment">// 输出“true”</span></span><br><span class="line">    <span class="keyword">val</span> boxedA: <span class="built_in">Int</span>? = a</span><br><span class="line">    <span class="keyword">val</span> anotherBoxedA: <span class="built_in">Int</span>? = a</span><br><span class="line">    println(boxedA == anotherBoxedA) <span class="comment">// 输出“true”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h3><p>由于不同的表示方式，较小类型并不是较大类型的子类型。<br>如果它们是的话，就会出现下述问题：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假想的代码，实际上并不能编译：</span></span><br><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span>? = <span class="number">1</span> <span class="comment">// 一个装箱的 Int (java.lang.Integer)</span></span><br><span class="line"><span class="keyword">val</span> b: <span class="built_in">Long</span>? = a <span class="comment">// 隐式转换产生一个装箱的 Long (java.lang.Long)</span></span><br><span class="line">print(b == a) <span class="comment">// 惊！这将输出“false”鉴于 Long 的 equals() 会检测另一个是否也为 Long</span></span><br></pre></td></tr></table></figure>
<p>所以相等性会在所有地方悄无声息地失去，更别说同一性了。</p>
<p>因此较小的类型<strong>不能</strong>隐式转换为较大的类型。<br>这意味着在不进行显式转换的情况下我们不能把 <code>Byte</code> 型值赋给一个 <code>Int</code> 变量。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> b: <span class="built_in">Byte</span> = <span class="number">1</span> <span class="comment">// OK, 字面值是静态检测的</span></span><br><span class="line">    <span class="keyword">val</span> i: <span class="built_in">Int</span> = b <span class="comment">// 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以显式转换来拓宽数字</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> b: <span class="built_in">Byte</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> i: <span class="built_in">Int</span> = b.toInt() <span class="comment">// OK：显式拓宽</span></span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个数字类型支持如下的转换:</p>
<ul>
<li><code>toByte(): Byte</code></li>
<li><code>toShort(): Short</code></li>
<li><code>toInt(): Int</code></li>
<li><code>toLong(): Long</code></li>
<li><code>toFloat(): Float</code></li>
<li><code>toDouble(): Double</code></li>
<li><code>toChar(): Char</code></li>
</ul>
<p>缺乏隐式类型转换很少会引起注意，因为类型会从上下文推断出来，而算术运算会有重载做适当转换，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l = <span class="number">1L</span> + <span class="number">3</span> <span class="comment">// Long + Int =&gt; Long</span></span><br></pre></td></tr></table></figure>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>Kotlin支持数字运算的标准集（<code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code>），运算被定义为相应的类成员（但编译器会将函数调用优化为相应的指令）。<br>参见<a href="operator-overloading.html">运算符重载</a>。</p>
<h4 id="整数除法"><a href="#整数除法" class="headerlink" title="整数除法"></a>整数除法</h4><p>请注意，整数间的除法总是返回整数。会丢弃任何小数部分。例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> x = <span class="number">5</span> / <span class="number">2</span></span><br><span class="line">    <span class="comment">//println(x == 2.5) // ERROR: Operator &#x27;==&#x27; cannot be applied to &#x27;Int&#x27; and &#x27;Double&#x27;</span></span><br><span class="line">    println(x == <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于任何两个整数类型之间的除法来说都是如此。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> x = <span class="number">5L</span> / <span class="number">2</span></span><br><span class="line">    println(x == <span class="number">2L</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如需返回浮点类型，请将其中的一个参数显式转换为浮点类型。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> x = <span class="number">5</span> / <span class="number">2.</span>toDouble()</span><br><span class="line">    println(x == <span class="number">2.5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>对于位运算，没有特殊字符来表示，而只可用中缀方式调用具名函数，例如:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = (<span class="number">1</span> shl <span class="number">2</span>) and <span class="number">0x000FF000</span></span><br></pre></td></tr></table></figure>
<p>这是完整的位运算列表（只用于 <code>Int</code> 与 <code>Long</code>）：</p>
<ul>
<li><code>shl(bits)</code> – 有符号左移</li>
<li><code>shr(bits)</code> – 有符号右移</li>
<li><code>ushr(bits)</code> – 无符号右移</li>
<li><code>and(bits)</code> – 位<strong>与</strong></li>
<li><code>or(bits)</code> – 位<strong>或</strong></li>
<li><code>xor(bits)</code> – 位<strong>异或</strong></li>
<li><code>inv()</code> – 位非</li>
</ul>
<h3 id="浮点数比较"><a href="#浮点数比较" class="headerlink" title="浮点数比较"></a>浮点数比较</h3><p>本节讨论的浮点数操作如下：</p>
<ul>
<li>相等性检测：<code>a == b</code> 与 <code>a != b</code></li>
<li>比较操作符：<code>a &lt; b</code>、 <code>a &gt; b</code>、 <code>a &lt;= b</code>、 <code>a &gt;= b</code></li>
<li>区间实例以及区间检测：<code>a..b</code>、 <code>x in a..b</code>、 <code>x !in a..b</code></li>
</ul>
<p>当其中的操作数 <code>a</code> 与 <code>b</code> 都是静态已知的 <code>Float</code> 或 <code>Double</code> 或者它们对应的可空类型（声明为该类型，或者推断为该类型，或者<a href="typecasts.html#%E6%99%BA%E8%83%BD%E8%BD%AC%E6%8D%A2">智能类型转换</a>的结果是该类型），两数字所形成的操作或者区间遵循 IEEE 754 浮点运算标准。</p>
<p>然而，为了支持泛型场景并提供全序支持，当这些操作数<strong>并非</strong>静态类型为浮点数（例如是 <code>Any</code>、 <code>Comparable&lt;……&gt;</code>、 类型参数）时，这些操作使用为 <code>Float</code> 与 <code>Double</code> 实现的不符合标准的 <code>equals</code> 与 <code>compareTo</code>，这会出现：</p>
<ul>
<li>认为 <code>NaN</code> 与其自身相等</li>
<li>认为 <code>NaN</code> 比包括正无穷大（<code>POSITIVE_INFINITY</code>）在内的任何其他元素都大</li>
<li>认为 <code>-0.0</code> 小于 <code>0.0</code></li>
</ul>
<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>字符用 <code>Char</code> 类型表示。它们不能直接当作数字</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">(c: <span class="type">Char</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) &#123; <span class="comment">// 错误：类型不兼容</span></span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符字面值用单引号括起来: <code>&#39;1&#39;</code>。<br>特殊字符可以用反斜杠转义。<br>支持这几个转义序列：<code>\t</code>、 <code>\b</code>、<code>\n</code>、<code>\r</code>、<code>\&#39;</code>、<code>\&quot;</code>、<code>\\</code> 与 <code>\$</code>。<br>编码其他字符要用 Unicode 转义序列语法：<code>&#39;\uFF00&#39;</code>。</p>
<p>我们可以显式把字符转换为 <code>Int</code> 数字：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">decimalDigitValue</span><span class="params">(c: <span class="type">Char</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c !<span class="keyword">in</span> <span class="string">&#x27;0&#x27;</span>..<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Out of range&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> c.toInt() - <span class="string">&#x27;0&#x27;</span>.toInt() <span class="comment">// 显式转换为数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当需要可空引用时，像数字、字符会被装箱。装箱操作不会保留同一性。</p>
<h2 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h2><p>布尔用 <code>Boolean</code> 类型表示，它有两个值：<em>true</em>{: .keyword } 与 <em>false</em>{: .keyword }。</p>
<p>若需要可空引用布尔会被装箱。</p>
<p>内置的布尔运算有：</p>
<ul>
<li><code>||</code> – 短路逻辑或</li>
<li><code>&amp;&amp;</code> – 短路逻辑与</li>
<li><code>!</code> - 逻辑非</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组在 Kotlin 中使用 <code>Array</code> 类来表示，它定义了 <code>get</code> 与 <code>set</code> 函数（按照运算符重载约定这会转变为 <code>[]</code>）以及 <code>size</code> 属性，以及一些其他有用的成员函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;<span class="type">T</span>&gt; <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> size: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: T</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(index: <span class="type">Int</span>, value: <span class="type">T</span>)</span></span>: <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;T&gt;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用库函数 <code>arrayOf()</code> 来创建一个数组并传递元素值给它，这样 <code>arrayOf(1, 2, 3)</code> 创建了 array <code>[1, 2, 3]</code>。<br>或者，库函数 <code>arrayOfNulls()</code> 可以用于创建一个指定大小的、所有元素都为空的数组。</p>
<p>另一个选项是用接受数组大小以及一个函数参数的 <code>Array</code> 构造函数，用作参数的函数能够返回给定索引的每个元素初始值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 Array&lt;String&gt; 初始化为 [&quot;0&quot;, &quot;1&quot;, &quot;4&quot;, &quot;9&quot;, &quot;16&quot;]</span></span><br><span class="line">    <span class="keyword">val</span> asc = Array(<span class="number">5</span>) &#123; i -&gt; (i * i).toString() &#125;</span><br><span class="line">    asc.forEach &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所述，<code>[]</code> 运算符代表调用成员函数 <code>get()</code> 与 <code>set()</code>。</p>
<p>Kotlin 中数组是<em>不型变的（invariant）</em>。这意味着 Kotlin 不让我们把 <code>Array&lt;String&gt;</code><br>赋值给 <code>Array&lt;Any&gt;</code>，以防止可能的运行时失败（但是你可以使用 <code>Array&lt;out Any&gt;</code>,<br>参见<a href="generics.html#%E7%B1%BB%E5%9E%8B%E6%8A%95%E5%BD%B1">类型投影</a>）。</p>
<h3 id="原生类型数组"><a href="#原生类型数组" class="headerlink" title="原生类型数组"></a>原生类型数组</h3><p>Kotlin 也有无装箱开销的专门的类来表示原生类型数组: <code>ByteArray</code>、<br><code>ShortArray</code>、<code>IntArray</code> 等等。这些类与 <code>Array</code> 并没有继承关系，但是它们有同样的方法属性集。它们也都有相应的工厂方法:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x: IntArray = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">x[<span class="number">0</span>] = x[<span class="number">1</span>] + x[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大小为 5、值为 [0, 0, 0, 0, 0] 的整型数组</span></span><br><span class="line"><span class="keyword">val</span> arr = IntArray(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如：用常量初始化数组中的值</span></span><br><span class="line"><span class="comment">// 大小为 5、值为 [42, 42, 42, 42, 42] 的整型数组</span></span><br><span class="line"><span class="keyword">val</span> arr = IntArray(<span class="number">5</span>) &#123; <span class="number">42</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如：使用 lambda 表达式初始化数组中的值</span></span><br><span class="line"><span class="comment">// 大小为 5、值为 [0, 1, 2, 3, 4] 的整型数组（值初始化为其索引值）</span></span><br><span class="line"><span class="keyword">var</span> arr = IntArray(<span class="number">5</span>) &#123; it * <span class="number">1</span> &#125; </span><br></pre></td></tr></table></figure>

<h2 id="无符号整型"><a href="#无符号整型" class="headerlink" title="无符号整型"></a>无符号整型</h2><blockquote>
<p>无符号类型自 Kotlin 1.3 起才可用，并且目前是<em>实验性的</em>。详见<a href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E5%9E%8B%E7%9A%84%E5%AE%9E%E9%AA%8C%E6%80%A7%E7%8A%B6%E6%80%81">下文</a><br>{:.note}</p>
</blockquote>
<p>Kotlin 为无符号整数引入了以下类型：</p>
<ul>
<li><code>kotlin.UByte</code>: 无符号 8 比特整数，范围是 0 到 255</li>
<li><code>kotlin.UShort</code>: 无符号 16 比特整数，范围是 0 到 65535</li>
<li><code>kotlin.UInt</code>: 无符号 32 比特整数，范围是 0 到 2^32 - 1</li>
<li><code>kotlin.ULong</code>: 无符号 64 比特整数，范围是 0 到 2^64 - 1</li>
</ul>
<p>无符号类型支持其对应有符号类型的大多数操作。</p>
<blockquote>
<p>请注意，将类型从无符号类型更改为对应的有符号类型（反之亦然）是<em>二进制不兼容</em>变更<br>{:.note}</p>
</blockquote>
<p>无符号类型是使用另一个实验性特性（即<a href="inline-classes.html">内联类</a>）实现的。</p>
<h3 id="特化的类"><a href="#特化的类" class="headerlink" title="特化的类"></a>特化的类</h3><p>与原生类型相同，每个无符号类型都有相应的为该类型特化的表示数组的类型：</p>
<ul>
<li><code>kotlin.UByteArray</code>: 无符号字节数组</li>
<li><code>kotlin.UShortArray</code>: 无符号短整型数组</li>
<li><code>kotlin.UIntArray</code>: 无符号整型数组</li>
<li><code>kotlin.ULongArray</code>: 无符号长整型数组</li>
</ul>
<p>与有符号整型数组一样，它们提供了类似于 <code>Array</code> 类的 API 而没有装箱开销。</p>
<p>此外，<a href="ranges.html">区间与数列</a>也支持 <code>UInt</code> 与 <code>ULong</code>（通过这些类 <code>kotlin.ranges.UIntRange</code>、 <code>kotlin.ranges.UIntProgression</code>、 <code>kotlin.ranges.ULongRange</code>、 <code>kotlin.ranges.ULongProgression</code>）</p>
<h3 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h3><p>为使无符号整型更易于使用，Kotlin 提供了用后缀标记整型字面值来表示指定无符号类型（类似于 Float/Long）：</p>
<ul>
<li>后缀 <code>u</code> 与 <code>U</code> 将字面值标记为无符号。确切类型会根据预期类型确定。如果没有提供预期的类型，会根据字面值大小选择 <code>UInt</code> 或者 <code>ULong</code></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> b: UByte = 1u  <span class="comment">// UByte，已提供预期类型</span></span><br><span class="line"><span class="keyword">val</span> s: UShort = 1u <span class="comment">// UShort，已提供预期类型</span></span><br><span class="line"><span class="keyword">val</span> l: ULong = 1u  <span class="comment">// ULong，已提供预期类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> a1 = 42u <span class="comment">// UInt：未提供预期类型，常量适于 UInt</span></span><br><span class="line"><span class="keyword">val</span> a2 = 0xFFFF_FFFF_FFFFu <span class="comment">// ULong：未提供预期类型，常量不适于 UInt</span></span><br></pre></td></tr></table></figure>
<ul>
<li>后缀 <code>uL</code> 与 <code>UL</code> 显式将字面值标记为无符号长整型。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = 1UL <span class="comment">// ULong，即使未提供预期类型并且常量适于 UInt</span></span><br></pre></td></tr></table></figure>
<h3 id="无符号整型的实验性状态"><a href="#无符号整型的实验性状态" class="headerlink" title="无符号整型的实验性状态"></a>无符号整型的实验性状态</h3><p>无符号类型的设计是实验性的，这意味着这个特性改进很快并且没有给出兼容性保证。当在 Kotlin 1.3+ 中使用无符号算术时，会报出警告表明这个特性是实验性的。如需移除警告，必须选择加入（opt-in）无符号类型的实验性使用。</p>
<p>选择加入无符号整型有两种可行的方式：将 API 标记为实验性的，或者无需标记。</p>
<ul>
<li>如需传播实验性，请以 <code>@ExperimentalUnsignedTypes</code> 标注使用了无符号整型的声明。</li>
<li>如需选择加入而不传播实验性，要么使用 <code>@OptIn(ExperimentalUnsignedTypes::class)</code> 注解标注声明，要么将 <code>-Xopt-in=kotlin.ExperimentalUnsignedTypes</code> 传给编译器。</li>
</ul>
<p>你的客户是否必须选择使用你的 API 取决于你，不过请记住，无符号整型是一个实验性特性，因此使用它们的 API 可能会因语言的变更而发生突然破坏。</p>
<p>技术细节也参见实验性 API <a target="_blank" rel="noopener" href="https://github.com/Kotlin/KEEP/blob/master/proposals/experimental.md">KEEP</a>。</p>
<h3 id="深入探讨"><a href="#深入探讨" class="headerlink" title="深入探讨"></a>深入探讨</h3><p>关于技术细节与深入探讨请参见<a target="_blank" rel="noopener" href="https://github.com/Kotlin/KEEP/blob/master/proposals/unsigned-types.md">无符号类型的语言提案</a>。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串用 <code>String</code> 类型表示。字符串是不可变的。<br>字符串的元素——字符可以使用索引运算符访问: <code>s[i]</code>。<br>可以用 <em>for</em>{: .keyword } 循环迭代字符串:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">&quot;abcd&quot;</span></span><br><span class="line">    <span class="keyword">for</span> (c <span class="keyword">in</span> str) &#123;</span><br><span class="line">        println(c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以用 <code>+</code> 操作符连接字符串。这也适用于连接字符串与其他类型的值，<br>只要表达式中的第一个元素是字符串：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">val</span> s = <span class="string">&quot;abc&quot;</span> + <span class="number">1</span></span><br><span class="line">println(s + <span class="string">&quot;def&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，在大多数情况下，优先使用<a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF">字符串模板</a>或原始字符串而不是字符串连接。</p>
<h3 id="字符串字面值"><a href="#字符串字面值" class="headerlink" title="字符串字面值"></a>字符串字面值</h3><p>Kotlin 有两种类型的字符串字面值: 转义字符串可以有转义字符，<br>以及原始字符串可以包含换行以及任意文本。以下是转义字符串的一个示例:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s = <span class="string">&quot;Hello, world!\n&quot;</span></span><br></pre></td></tr></table></figure>
<p>转义采用传统的反斜杠方式。参见上面的 <a href="#%E5%AD%97%E7%AC%A6">字符</a> 查看支持的转义序列。</p>
<p><em>原始字符串</em> 使用三个引号（<code>&quot;&quot;&quot;</code>）分界符括起来，内部没有转义并且可以包含换行以及任何其他字符:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    for (c in &quot;foo&quot;)</span></span><br><span class="line"><span class="string">        print(c)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>你可以通过 <a target="_blank" rel="noopener" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/trim-margin.html"><code>trimMargin()</code></a> 函数去除前导空格：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    |Tell me and I forget.</span></span><br><span class="line"><span class="string">    |Teach me and I remember.</span></span><br><span class="line"><span class="string">    |Involve me and I learn.</span></span><br><span class="line"><span class="string">    |(Benjamin Franklin)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>.trimMargin()</span><br></pre></td></tr></table></figure>
<p>默认 <code>|</code> 用作边界前缀，但你可以选择其他字符并作为参数传入，比如 <code>trimMargin(&quot;&gt;&quot;)</code>。</p>
<h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><p>字符串字面值可以包含<em>模板表达式</em> ，即一些小段代码，会求值并把结果合并到字符串中。<br>模板表达式以美元符（<code>$</code>）开头，由一个简单的名字构成:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> i = <span class="number">10</span></span><br><span class="line">    println(<span class="string">&quot;i = <span class="variable">$i</span>&quot;</span>) <span class="comment">// 输出“i = 10”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者用花括号括起来的任意表达式:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> s = <span class="string">&quot;abc&quot;</span></span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$s</span>.length is <span class="subst">$&#123;s.length&#125;</span>&quot;</span>) <span class="comment">// 输出“abc.length is 3”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原始字符串与转义字符串内部都支持模板。<br>如果你需要在原始字符串中表示字面值 <code>$</code> 字符（它不支持反斜杠转义），你可以用下列语法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> price = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"><span class="subst">$&#123;<span class="string">&#x27;$&#x27;</span>&#125;</span>9.99</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5>本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "http://example.com/2020/07/14/kotlin%20%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "http://example.com/2020/07/14/kotlin%20%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/";
            const title         = "「kotlin 基本类型」";
            const excerpt       = `基本类型在 Kotlin 中，所有东西都是对象，在这个意义上讲我们可以在任何变量上调用成员函数与属性。一些类型可以有特殊的内部表示——例如，数字、字符以及布尔值可以在运行时表示为原生类型值，但是对于用户来说，它们看起来就像普通的类。在本节中，我们会描述 Kotlin 中使用的基本类型：数字、字符、布尔值、数组与字符串。`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    <a class="tag-none-link" href="/tags/Conclusion/" rel="tag">Conclusion</a>
                </div>
                <div class="pull-date">
                <span>最后编辑：2021-04-10</span>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" Hello World !" href="/2020/04/15/helloworld/">&lt; 上一篇</a>
            </div>
            
            
            <div class="nav-next clearfix">
                <a title=" [活动预告] 危机合约 #4 赛季「铅封行动」即将开启" target="_blank" rel="noopener" href="//news/">下一篇 &gt;</a>
            </div>
            
        </nav>
    
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/avatar.webp" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center"></p>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                
  <aside id="krw-categories" class="widget widget-kratos-categories clearfix">
    <h4 class="widget-title"><i class="fa fa-folder"></i>分类目录</h4>
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BE%8B%E5%AD%90/">例子</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%BB%E7%BB%93/">总结</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%99%E7%A8%8B/">教程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B4%BB%E5%8A%A8/">活动</a><span class="category-list-count">1</span></li></ul>
  </aside>


            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/Activity/" style="font-size: 0.6em;">Activity</a> <a href="/tags/Conclusion/" style="font-size: 0.8em;">Conclusion</a> <a href="/tags/Course/" style="font-size: 0.67em;">Course</a> <a href="/tags/Example/" style="font-size: 0.73em;">Example</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2021/04/09/Java%E5%B8%B8%E8%A7%81%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93/"><i class="fa  fa-book"></i> Java常见关键字总结</a>
            
          
        
          
          
            <a class="list-group-item" href="/2021/04/09/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><i class="fa  fa-book"></i> Java基础知识</a>
            
          
        
          
          
            <a class="list-group-item" href="/2021/01/29/%E6%B0%B8%E4%B9%85%E5%85%8D%E8%B4%B9%E7%9A%84%E7%94%B2%E9%AA%A8%E6%96%87Oracle%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B3%A8%E5%86%8C%E6%95%99%E7%A8%8B%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"><i class="fa  fa-book"></i> 永久免费的甲骨文oracle服务器注册教程及注意事项</a>
            
          
        
          
          
            <a class="list-group-item" href="/2021/01/29/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><i class="fa  fa-book"></i> 常用正则表达式</a>
            
          
        
          
          
            <a class="list-group-item" href="/news/"><i class="fa  fa-book"></i> [活动预告] 危机合约 #4 赛季「铅封行动」即将开启</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        
                        
                        <li><a target="_blank" rel="nofollow" href="https://t.me/CandyUnion"><i class="fa fa-telegram"></i></a></li>
                        
                        
                        
                        <li><a target="_blank" rel="me" href="https://nya.one/@Candinya"><i class="fa fa fa-share-alt-square"></i></a></li>
                        <li><a target="_blank" rel="nofollow" href="https://github.com/Candinya"><i class="fa fa-github"></i></a></li>
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2021 凌 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by Yue_plus.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>
<script>const notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));</script>


    <script async src="/js/candy.min.js"></script>



    <script defer src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="3204190542"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script>
<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>


    <script defer src="/js/kr-dark.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>